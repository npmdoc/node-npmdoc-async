<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/caolan/async#readme">async (v2.3.0)</a>
</h1>
<h4>Higher-order functions and common patterns for asynchronous code</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.async">module async</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList">
            function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.all">
            function <span class="apidocSignatureSpan">async.</span>all
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.allLimit">
            function <span class="apidocSignatureSpan">async.</span>allLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.allSeries">
            function <span class="apidocSignatureSpan">async.</span>allSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.any">
            function <span class="apidocSignatureSpan">async.</span>any
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.anyLimit">
            function <span class="apidocSignatureSpan">async.</span>anyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.anySeries">
            function <span class="apidocSignatureSpan">async.</span>anySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.apply">
            function <span class="apidocSignatureSpan">async.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.apply.apply">
            function <span class="apidocSignatureSpan">async.</span>apply.apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEach">
            function <span class="apidocSignatureSpan">async.</span>applyEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEachSeries">
            function <span class="apidocSignatureSpan">async.</span>applyEachSeries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.asyncify">
            function <span class="apidocSignatureSpan">async.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.auto">
            function <span class="apidocSignatureSpan">async.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.autoInject">
            function <span class="apidocSignatureSpan">async.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.cargo">
            function <span class="apidocSignatureSpan">async.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.compose">
            function <span class="apidocSignatureSpan">async.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concat">
            function <span class="apidocSignatureSpan">async.</span>concat
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concatSeries">
            function <span class="apidocSignatureSpan">async.</span>concatSeries
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.consoleFunc">
            function <span class="apidocSignatureSpan">async.</span>consoleFunc
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.constant">
            function <span class="apidocSignatureSpan">async.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.createTester">
            function <span class="apidocSignatureSpan">async.</span>createTester
            <span class="apidocSignatureSpan">(check, getResult)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detect">
            function <span class="apidocSignatureSpan">async.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectLimit">
            function <span class="apidocSignatureSpan">async.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectSeries">
            function <span class="apidocSignatureSpan">async.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.dir">
            function <span class="apidocSignatureSpan">async.</span>dir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doDuring">
            function <span class="apidocSignatureSpan">async.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doLimit">
            function <span class="apidocSignatureSpan">async.</span>doLimit
            <span class="apidocSignatureSpan">(fn, limit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doParallel">
            function <span class="apidocSignatureSpan">async.</span>doParallel
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doParallelLimit">
            function <span class="apidocSignatureSpan">async.</span>doParallelLimit
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doSeries">
            function <span class="apidocSignatureSpan">async.</span>doSeries
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doUntil">
            function <span class="apidocSignatureSpan">async.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doWhilst">
            function <span class="apidocSignatureSpan">async.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.during">
            function <span class="apidocSignatureSpan">async.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.each">
            function <span class="apidocSignatureSpan">async.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachLimit">
            function <span class="apidocSignatureSpan">async.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOf">
            function <span class="apidocSignatureSpan">async.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfLimit">
            function <span class="apidocSignatureSpan">async.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfSeries">
            function <span class="apidocSignatureSpan">async.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachSeries">
            function <span class="apidocSignatureSpan">async.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.ensureAsync">
            function <span class="apidocSignatureSpan">async.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.every">
            function <span class="apidocSignatureSpan">async.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everyLimit">
            function <span class="apidocSignatureSpan">async.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everySeries">
            function <span class="apidocSignatureSpan">async.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filter">
            function <span class="apidocSignatureSpan">async.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterLimit">
            function <span class="apidocSignatureSpan">async.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterSeries">
            function <span class="apidocSignatureSpan">async.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.find">
            function <span class="apidocSignatureSpan">async.</span>find
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findGetResult">
            function <span class="apidocSignatureSpan">async.</span>findGetResult
            <span class="apidocSignatureSpan">(v, x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findLimit">
            function <span class="apidocSignatureSpan">async.</span>findLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findSeries">
            function <span class="apidocSignatureSpan">async.</span>findSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.foldl">
            function <span class="apidocSignatureSpan">async.</span>foldl
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.foldr">
            function <span class="apidocSignatureSpan">async.</span>foldr
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEach">
            function <span class="apidocSignatureSpan">async.</span>forEach
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachLimit">
            function <span class="apidocSignatureSpan">async.</span>forEachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOf">
            function <span class="apidocSignatureSpan">async.</span>forEachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOfLimit">
            function <span class="apidocSignatureSpan">async.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOfSeries">
            function <span class="apidocSignatureSpan">async.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachSeries">
            function <span class="apidocSignatureSpan">async.</span>forEachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forever">
            function <span class="apidocSignatureSpan">async.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.getIterator">
            function <span class="apidocSignatureSpan">async.</span>getIterator
            <span class="apidocSignatureSpan">(coll)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBy">
            function <span class="apidocSignatureSpan">async.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupByLimit">
            function <span class="apidocSignatureSpan">async.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBySeries">
            function <span class="apidocSignatureSpan">async.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.initialParams">
            function <span class="apidocSignatureSpan">async.</span>initialParams
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.inject">
            function <span class="apidocSignatureSpan">async.</span>inject
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.iterator">
            function <span class="apidocSignatureSpan">async.</span>iterator
            <span class="apidocSignatureSpan">(coll)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.log">
            function <span class="apidocSignatureSpan">async.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.map">
            function <span class="apidocSignatureSpan">async.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapLimit">
            function <span class="apidocSignatureSpan">async.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapSeries">
            function <span class="apidocSignatureSpan">async.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValues">
            function <span class="apidocSignatureSpan">async.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.memoize">
            function <span class="apidocSignatureSpan">async.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.nextTick">
            function <span class="apidocSignatureSpan">async.</span>nextTick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.notId">
            function <span class="apidocSignatureSpan">async.</span>notId
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.once">
            function <span class="apidocSignatureSpan">async.</span>once
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.onlyOnce">
            function <span class="apidocSignatureSpan">async.</span>onlyOnce
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallel">
            function <span class="apidocSignatureSpan">async.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallelLimit">
            function <span class="apidocSignatureSpan">async.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.priorityQueue">
            function <span class="apidocSignatureSpan">async.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.queue">
            function <span class="apidocSignatureSpan">async.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.race">
            function <span class="apidocSignatureSpan">async.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduce">
            function <span class="apidocSignatureSpan">async.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduceRight">
            function <span class="apidocSignatureSpan">async.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflect">
            function <span class="apidocSignatureSpan">async.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflectAll">
            function <span class="apidocSignatureSpan">async.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reject">
            function <span class="apidocSignatureSpan">async.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectLimit">
            function <span class="apidocSignatureSpan">async.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectSeries">
            function <span class="apidocSignatureSpan">async.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rest">
            function <span class="apidocSignatureSpan">async.</span>rest
            <span class="apidocSignatureSpan">(func, start)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retry">
            function <span class="apidocSignatureSpan">async.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retryable">
            function <span class="apidocSignatureSpan">async.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.select">
            function <span class="apidocSignatureSpan">async.</span>select
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.selectLimit">
            function <span class="apidocSignatureSpan">async.</span>selectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.selectSeries">
            function <span class="apidocSignatureSpan">async.</span>selectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.seq">
            function <span class="apidocSignatureSpan">async.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.series">
            function <span class="apidocSignatureSpan">async.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.setImmediate">
            function <span class="apidocSignatureSpan">async.</span>setImmediate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.some">
            function <span class="apidocSignatureSpan">async.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someLimit">
            function <span class="apidocSignatureSpan">async.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someSeries">
            function <span class="apidocSignatureSpan">async.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.sortBy">
            function <span class="apidocSignatureSpan">async.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timeout">
            function <span class="apidocSignatureSpan">async.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.times">
            function <span class="apidocSignatureSpan">async.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesLimit">
            function <span class="apidocSignatureSpan">async.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesSeries">
            function <span class="apidocSignatureSpan">async.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.transform">
            function <span class="apidocSignatureSpan">async.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.unmemoize">
            function <span class="apidocSignatureSpan">async.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.until">
            function <span class="apidocSignatureSpan">async.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.waterfall">
            function <span class="apidocSignatureSpan">async.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.whilst">
            function <span class="apidocSignatureSpan">async.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.withoutIndex">
            function <span class="apidocSignatureSpan">async.</span>withoutIndex
            <span class="apidocSignatureSpan">(iteratee)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapSync">
            function <span class="apidocSignatureSpan">async.</span>wrapSync
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>DoublyLinkedList.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>wrapAsync</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.DoublyLinkedList">module async.DoublyLinkedList</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.DoublyLinkedList">
            function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.DoublyLinkedList.prototype">module async.DoublyLinkedList.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.empty">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.insertAfter">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(node, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.insertBefore">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(node, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.pop">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.push">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.removeLink">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>removeLink
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.shift">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.unshift">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.apply">module async.apply</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.apply.apply">
            function <span class="apidocSignatureSpan">async.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.apply.apply">module async.apply.apply</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.apply.apply.apply">
            function <span class="apidocSignatureSpan">async.apply.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.applyEach">module async.applyEach</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEach.applyEach">
            function <span class="apidocSignatureSpan">async.</span>applyEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.applyEachSeries">module async.applyEachSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEachSeries.applyEachSeries">
            function <span class="apidocSignatureSpan">async.</span>applyEachSeries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.asyncify">module async.asyncify</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.asyncify.asyncify">
            function <span class="apidocSignatureSpan">async.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.auto">module async.auto</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.auto.auto">
            function <span class="apidocSignatureSpan">async.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.autoInject">module async.autoInject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.autoInject.autoInject">
            function <span class="apidocSignatureSpan">async.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.cargo">module async.cargo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.cargo.cargo">
            function <span class="apidocSignatureSpan">async.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.compose">module async.compose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.compose.compose">
            function <span class="apidocSignatureSpan">async.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.concat">module async.concat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concat.concat">
            function <span class="apidocSignatureSpan">async.</span>concat
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.concatSeries">module async.concatSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concatSeries.concatSeries">
            function <span class="apidocSignatureSpan">async.</span>concatSeries
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.consoleFunc">module async.consoleFunc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.consoleFunc.consoleFunc">
            function <span class="apidocSignatureSpan">async.</span>consoleFunc
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.constant">module async.constant</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.constant.constant">
            function <span class="apidocSignatureSpan">async.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.createTester">module async.createTester</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.createTester.createTester">
            function <span class="apidocSignatureSpan">async.</span>createTester
            <span class="apidocSignatureSpan">(check, getResult)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.default">module async.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.all">
            function <span class="apidocSignatureSpan">async.default.</span>all
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.any">
            function <span class="apidocSignatureSpan">async.default.</span>any
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.apply">
            function <span class="apidocSignatureSpan">async.default.</span>apply
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.applyEach">
            function <span class="apidocSignatureSpan">async.default.</span>applyEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.applyEachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>applyEachSeries
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.asyncify">
            function <span class="apidocSignatureSpan">async.default.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.auto">
            function <span class="apidocSignatureSpan">async.default.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.autoInject">
            function <span class="apidocSignatureSpan">async.default.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.cargo">
            function <span class="apidocSignatureSpan">async.default.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.compose">
            function <span class="apidocSignatureSpan">async.default.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.concat">
            function <span class="apidocSignatureSpan">async.default.</span>concat
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.concatSeries">
            function <span class="apidocSignatureSpan">async.default.</span>concatSeries
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.constant">
            function <span class="apidocSignatureSpan">async.default.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detect">
            function <span class="apidocSignatureSpan">async.default.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.dir">
            function <span class="apidocSignatureSpan">async.default.</span>dir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doDuring">
            function <span class="apidocSignatureSpan">async.default.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doUntil">
            function <span class="apidocSignatureSpan">async.default.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doWhilst">
            function <span class="apidocSignatureSpan">async.default.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.during">
            function <span class="apidocSignatureSpan">async.default.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.each">
            function <span class="apidocSignatureSpan">async.default.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachLimit">
            function <span class="apidocSignatureSpan">async.default.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOf">
            function <span class="apidocSignatureSpan">async.default.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOfLimit">
            function <span class="apidocSignatureSpan">async.default.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOfSeries">
            function <span class="apidocSignatureSpan">async.default.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.ensureAsync">
            function <span class="apidocSignatureSpan">async.default.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.every">
            function <span class="apidocSignatureSpan">async.default.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.everyLimit">
            function <span class="apidocSignatureSpan">async.default.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.everySeries">
            function <span class="apidocSignatureSpan">async.default.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filter">
            function <span class="apidocSignatureSpan">async.default.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filterLimit">
            function <span class="apidocSignatureSpan">async.default.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filterSeries">
            function <span class="apidocSignatureSpan">async.default.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.foldl">
            function <span class="apidocSignatureSpan">async.default.</span>foldl
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.foldr">
            function <span class="apidocSignatureSpan">async.default.</span>foldr
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEach">
            function <span class="apidocSignatureSpan">async.default.</span>forEach
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachLimit">
            function <span class="apidocSignatureSpan">async.default.</span>forEachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOf">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOfLimit">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOfSeries">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>forEachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forever">
            function <span class="apidocSignatureSpan">async.default.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupBy">
            function <span class="apidocSignatureSpan">async.default.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupByLimit">
            function <span class="apidocSignatureSpan">async.default.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupBySeries">
            function <span class="apidocSignatureSpan">async.default.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.inject">
            function <span class="apidocSignatureSpan">async.default.</span>inject
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.log">
            function <span class="apidocSignatureSpan">async.default.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.map">
            function <span class="apidocSignatureSpan">async.default.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapLimit">
            function <span class="apidocSignatureSpan">async.default.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapSeries">
            function <span class="apidocSignatureSpan">async.default.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValues">
            function <span class="apidocSignatureSpan">async.default.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.default.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.default.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.memoize">
            function <span class="apidocSignatureSpan">async.default.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.nextTick">
            function <span class="apidocSignatureSpan">async.default.</span>nextTick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.parallel">
            function <span class="apidocSignatureSpan">async.default.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.parallelLimit">
            function <span class="apidocSignatureSpan">async.default.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.priorityQueue">
            function <span class="apidocSignatureSpan">async.default.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.queue">
            function <span class="apidocSignatureSpan">async.default.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.race">
            function <span class="apidocSignatureSpan">async.default.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reduce">
            function <span class="apidocSignatureSpan">async.default.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reduceRight">
            function <span class="apidocSignatureSpan">async.default.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reflect">
            function <span class="apidocSignatureSpan">async.default.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reflectAll">
            function <span class="apidocSignatureSpan">async.default.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reject">
            function <span class="apidocSignatureSpan">async.default.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.rejectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.rejectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.retry">
            function <span class="apidocSignatureSpan">async.default.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.retryable">
            function <span class="apidocSignatureSpan">async.default.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.select">
            function <span class="apidocSignatureSpan">async.default.</span>select
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.selectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>selectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.selectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>selectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.seq">
            function <span class="apidocSignatureSpan">async.default.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.series">
            function <span class="apidocSignatureSpan">async.default.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.setImmediate">
            function <span class="apidocSignatureSpan">async.default.</span>setImmediate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.some">
            function <span class="apidocSignatureSpan">async.default.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.someLimit">
            function <span class="apidocSignatureSpan">async.default.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.someSeries">
            function <span class="apidocSignatureSpan">async.default.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.sortBy">
            function <span class="apidocSignatureSpan">async.default.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timeout">
            function <span class="apidocSignatureSpan">async.default.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.times">
            function <span class="apidocSignatureSpan">async.default.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timesLimit">
            function <span class="apidocSignatureSpan">async.default.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timesSeries">
            function <span class="apidocSignatureSpan">async.default.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.transform">
            function <span class="apidocSignatureSpan">async.default.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.unmemoize">
            function <span class="apidocSignatureSpan">async.default.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.until">
            function <span class="apidocSignatureSpan">async.default.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.waterfall">
            function <span class="apidocSignatureSpan">async.default.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.whilst">
            function <span class="apidocSignatureSpan">async.default.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.wrapSync">
            function <span class="apidocSignatureSpan">async.default.</span>wrapSync
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.detect">module async.detect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detect.detect">
            function <span class="apidocSignatureSpan">async.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.detectLimit">module async.detectLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectLimit.detectLimit">
            function <span class="apidocSignatureSpan">async.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.detectSeries">module async.detectSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectSeries.detectSeries">
            function <span class="apidocSignatureSpan">async.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.dir">module async.dir</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.dir.dir">
            function <span class="apidocSignatureSpan">async.</span>dir
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doDuring">module async.doDuring</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doDuring.doDuring">
            function <span class="apidocSignatureSpan">async.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doLimit">module async.doLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doLimit.doLimit">
            function <span class="apidocSignatureSpan">async.</span>doLimit
            <span class="apidocSignatureSpan">(fn, limit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doParallel">module async.doParallel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doParallel.doParallel">
            function <span class="apidocSignatureSpan">async.</span>doParallel
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doParallelLimit">module async.doParallelLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doParallelLimit.doParallelLimit">
            function <span class="apidocSignatureSpan">async.</span>doParallelLimit
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doSeries">module async.doSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doSeries.doSeries">
            function <span class="apidocSignatureSpan">async.</span>doSeries
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doUntil">module async.doUntil</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doUntil.doUntil">
            function <span class="apidocSignatureSpan">async.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.doWhilst">module async.doWhilst</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doWhilst.doWhilst">
            function <span class="apidocSignatureSpan">async.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.during">module async.during</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.during.during">
            function <span class="apidocSignatureSpan">async.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.each">module async.each</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.each.each">
            function <span class="apidocSignatureSpan">async.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.eachLimit">module async.eachLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachLimit.eachLimit">
            function <span class="apidocSignatureSpan">async.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.eachOf">module async.eachOf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOf.eachOf">
            function <span class="apidocSignatureSpan">async.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.eachOfLimit">module async.eachOfLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfLimit.eachOfLimit">
            function <span class="apidocSignatureSpan">async.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.eachOfSeries">module async.eachOfSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfSeries.eachOfSeries">
            function <span class="apidocSignatureSpan">async.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.eachSeries">module async.eachSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachSeries.eachSeries">
            function <span class="apidocSignatureSpan">async.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.ensureAsync">module async.ensureAsync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.ensureAsync.ensureAsync">
            function <span class="apidocSignatureSpan">async.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.every">module async.every</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.every.every">
            function <span class="apidocSignatureSpan">async.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.everyLimit">module async.everyLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everyLimit.everyLimit">
            function <span class="apidocSignatureSpan">async.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.everySeries">module async.everySeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everySeries.everySeries">
            function <span class="apidocSignatureSpan">async.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.filter">module async.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filter.filter">
            function <span class="apidocSignatureSpan">async.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.filterLimit">module async.filterLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterLimit.filterLimit">
            function <span class="apidocSignatureSpan">async.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.filterSeries">module async.filterSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterSeries.filterSeries">
            function <span class="apidocSignatureSpan">async.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.findGetResult">module async.findGetResult</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findGetResult.findGetResult">
            function <span class="apidocSignatureSpan">async.</span>findGetResult
            <span class="apidocSignatureSpan">(v, x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.forever">module async.forever</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forever.forever">
            function <span class="apidocSignatureSpan">async.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.getIterator">module async.getIterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.getIterator.getIterator">
            function <span class="apidocSignatureSpan">async.</span>getIterator
            <span class="apidocSignatureSpan">(coll)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.groupBy">module async.groupBy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBy.groupBy">
            function <span class="apidocSignatureSpan">async.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.groupByLimit">module async.groupByLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupByLimit.groupByLimit">
            function <span class="apidocSignatureSpan">async.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.groupBySeries">module async.groupBySeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBySeries.groupBySeries">
            function <span class="apidocSignatureSpan">async.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.initialParams">module async.initialParams</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.initialParams.initialParams">
            function <span class="apidocSignatureSpan">async.</span>initialParams
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.iterator">module async.iterator</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.iterator.iterator">
            function <span class="apidocSignatureSpan">async.</span>iterator
            <span class="apidocSignatureSpan">(coll)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.log">module async.log</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.log.log">
            function <span class="apidocSignatureSpan">async.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.map">module async.map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.map.map">
            function <span class="apidocSignatureSpan">async.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.mapLimit">module async.mapLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapLimit.mapLimit">
            function <span class="apidocSignatureSpan">async.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.mapSeries">module async.mapSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapSeries.mapSeries">
            function <span class="apidocSignatureSpan">async.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.mapValues">module async.mapValues</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValues.mapValues">
            function <span class="apidocSignatureSpan">async.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.mapValuesLimit">module async.mapValuesLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesLimit.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.mapValuesSeries">module async.mapValuesSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesSeries.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.memoize">module async.memoize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.memoize.memoize">
            function <span class="apidocSignatureSpan">async.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.nextTick">module async.nextTick</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.nextTick.nextTick">
            function <span class="apidocSignatureSpan">async.</span>nextTick
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.notId">module async.notId</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.notId.notId">
            function <span class="apidocSignatureSpan">async.</span>notId
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.once">module async.once</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.once.once">
            function <span class="apidocSignatureSpan">async.</span>once
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.onlyOnce">module async.onlyOnce</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.onlyOnce.onlyOnce">
            function <span class="apidocSignatureSpan">async.</span>onlyOnce
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.parallel">module async.parallel</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallel.parallel">
            function <span class="apidocSignatureSpan">async.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.parallelLimit">module async.parallelLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallelLimit.parallelLimit">
            function <span class="apidocSignatureSpan">async.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.priorityQueue">module async.priorityQueue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.priorityQueue.priorityQueue">
            function <span class="apidocSignatureSpan">async.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.queue">module async.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.queue.queue">
            function <span class="apidocSignatureSpan">async.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.race">module async.race</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.race.race">
            function <span class="apidocSignatureSpan">async.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.reduce">module async.reduce</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduce.reduce">
            function <span class="apidocSignatureSpan">async.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.reduceRight">module async.reduceRight</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduceRight.reduceRight">
            function <span class="apidocSignatureSpan">async.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.reflect">module async.reflect</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflect.reflect">
            function <span class="apidocSignatureSpan">async.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.reflectAll">module async.reflectAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflectAll.reflectAll">
            function <span class="apidocSignatureSpan">async.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.reject">module async.reject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reject.reject">
            function <span class="apidocSignatureSpan">async.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.rejectLimit">module async.rejectLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectLimit.rejectLimit">
            function <span class="apidocSignatureSpan">async.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.rejectSeries">module async.rejectSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectSeries.rejectSeries">
            function <span class="apidocSignatureSpan">async.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.rest">module async.rest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rest.rest">
            function <span class="apidocSignatureSpan">async.</span>rest
            <span class="apidocSignatureSpan">(func, start)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.retry">module async.retry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retry.retry">
            function <span class="apidocSignatureSpan">async.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.retryable">module async.retryable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retryable.retryable">
            function <span class="apidocSignatureSpan">async.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.seq">module async.seq</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.seq.seq">
            function <span class="apidocSignatureSpan">async.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.series">module async.series</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.series.series">
            function <span class="apidocSignatureSpan">async.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.setImmediate">module async.setImmediate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.setImmediate.setImmediate">
            function <span class="apidocSignatureSpan">async.</span>setImmediate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.some">module async.some</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.some.some">
            function <span class="apidocSignatureSpan">async.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.someLimit">module async.someLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someLimit.someLimit">
            function <span class="apidocSignatureSpan">async.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.someSeries">module async.someSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someSeries.someSeries">
            function <span class="apidocSignatureSpan">async.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.sortBy">module async.sortBy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.sortBy.sortBy">
            function <span class="apidocSignatureSpan">async.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.timeout">module async.timeout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timeout.timeout">
            function <span class="apidocSignatureSpan">async.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.times">module async.times</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.times.times">
            function <span class="apidocSignatureSpan">async.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.timesLimit">module async.timesLimit</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesLimit.timesLimit">
            function <span class="apidocSignatureSpan">async.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.timesSeries">module async.timesSeries</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesSeries.timesSeries">
            function <span class="apidocSignatureSpan">async.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.transform">module async.transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.transform.transform">
            function <span class="apidocSignatureSpan">async.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.unmemoize">module async.unmemoize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.unmemoize.unmemoize">
            function <span class="apidocSignatureSpan">async.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.until">module async.until</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.until.until">
            function <span class="apidocSignatureSpan">async.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.waterfall">module async.waterfall</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.waterfall.waterfall">
            function <span class="apidocSignatureSpan">async.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.whilst">module async.whilst</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.whilst.whilst">
            function <span class="apidocSignatureSpan">async.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.withoutIndex">module async.withoutIndex</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.withoutIndex.withoutIndex">
            function <span class="apidocSignatureSpan">async.</span>withoutIndex
            <span class="apidocSignatureSpan">(iteratee)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.wrapAsync">module async.wrapAsync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapAsync.default">
            function <span class="apidocSignatureSpan">async.wrapAsync.</span>default
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapAsync.isAsync">
            function <span class="apidocSignatureSpan">async.wrapAsync.</span>isAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapAsync.supportsAsync">
            function <span class="apidocSignatureSpan">async.wrapAsync.</span>supportsAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async" id="apidoc.module.async">module async</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList" id="apidoc.element.async.DoublyLinkedList">
        function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.all" id="apidoc.element.async.all">
        function <span class="apidocSignatureSpan">async.</span>all
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.allLimit" id="apidoc.element.async.allLimit">
        function <span class="apidocSignatureSpan">async.</span>allLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.allSeries" id="apidoc.element.async.allSeries">
        function <span class="apidocSignatureSpan">async.</span>allSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.any" id="apidoc.element.async.any">
        function <span class="apidocSignatureSpan">async.</span>any
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.anyLimit" id="apidoc.element.async.anyLimit">
        function <span class="apidocSignatureSpan">async.</span>anyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.anySeries" id="apidoc.element.async.anySeries">
        function <span class="apidocSignatureSpan">async.</span>anySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.apply" id="apidoc.element.async.apply">
        function <span class="apidocSignatureSpan">async.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">apply</span>(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
*     function(callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.apply.apply" id="apidoc.element.async.apply.apply">
        function <span class="apidocSignatureSpan">async.</span>apply.apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.applyEach" id="apidoc.element.async.applyEach">
        function <span class="apidocSignatureSpan">async.</span>applyEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], 'bucket', callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.applyEachSeries" id="apidoc.element.async.applyEachSeries">
        function <span class="apidocSignatureSpan">async.</span>applyEachSeries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.asyncify" id="apidoc.element.async.asyncify">
        function <span class="apidocSignatureSpan">async.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === 'function') {
            result.then(function (value) {
                callback(null, value);
            }, function (err) {
                callback(err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.auto" id="apidoc.element.async.auto">
        function <span class="apidocSignatureSpan">async.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies
.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }
    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }

    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(rest(function (err, args) {
            runningTasks--;
            if (args.length &lt;= 1) {
                args = args[0];
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function (val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = args;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = args;
                taskComplete(key);
            }
        }));

        runningTasks++;
        var taskFn = wrapAsync$1(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function ( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
*     showData: ['readData', function(results, cb) {
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.autoInject" id="apidoc.element.async.autoInject">
        function <span class="apidocSignatureSpan">async.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync &amp;&amp; taskFn.length === 1 || fnIsAsync &amp;&amp; taskFn.length === 0;

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync$1(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.cargo" id="apidoc.element.async.cargo">
        function <span class="apidocSignatureSpan">async.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return queue(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log('hello ' + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.compose" id="apidoc.element.async.compose">
        function <span class="apidocSignatureSpan">async.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
exports.default = (0, _rest2.default)(function (args) {
  return _seq2.default.apply(null, args.reverse());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.concat" id="apidoc.element.async.concat">
        function <span class="apidocSignatureSpan">async.</span>concat
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * node&gt; fn('two', 'three');
 * one
 * two
 * three
 */
exports.default = (0, _rest2.default)(function (fn, args) {
    return (0, _rest2.default)(function (callArgs) {
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    });
});
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.concatSeries" id="apidoc.element.async.concatSeries">
        function <span class="apidocSignatureSpan">async.</span>concatSeries
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (obj, iteratee, callback) {
    return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.consoleFunc" id="apidoc.element.async.consoleFunc">
        function <span class="apidocSignatureSpan">async.</span>consoleFunc
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function consoleFunc(name) {
    return (0, _rest2.default)(function (fn, args) {
        (0, _wrapAsync2.default)(fn).apply(null, args.concat((0, _rest2.default)(function (err, args) {
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    (0, _arrayEach2.default)(args, function (x) {
                        console[name](x);
                    });
                }
            }
        })));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.constant" id="apidoc.element.async.constant">
        function <span class="apidocSignatureSpan">async.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.createTester" id="apidoc.element.async.createTester">
        function <span class="apidocSignatureSpan">async.</span>createTester
        <span class="apidocSignatureSpan">(check, getResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createTester(check, getResult) {
    return function (eachfn, arr, iteratee, cb) {
        cb = cb || _noop2.default;
        var testPassed = false;
        var testResult;
        eachfn(arr, function (value, _, callback) {
            iteratee(value, function (err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) &amp;&amp; !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, _breakLoop2.default);
                } else {
                    callback();
                }
            });
        }, function (err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detect" id="apidoc.element.async.detect">
        function <span class="apidocSignatureSpan">async.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detectLimit" id="apidoc.element.async.detectLimit">
        function <span class="apidocSignatureSpan">async.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detectSeries" id="apidoc.element.async.detectSeries">
        function <span class="apidocSignatureSpan">async.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.dir" id="apidoc.element.async.dir">
        function <span class="apidocSignatureSpan">async.</span>dir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, 'world');
 * {hello: 'world'}
 */
exports.default = (0, _consoleFunc2.default)('dir');
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doDuring" id="apidoc.element.async.doDuring">
        function <span class="apidocSignatureSpan">async.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    var next = rest(function (err, args) {
        if (err) return callback(err);
        args.push(check);
        _test.apply(this, args);
    });

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doLimit" id="apidoc.element.async.doLimit">
        function <span class="apidocSignatureSpan">async.</span>doLimit
        <span class="apidocSignatureSpan">(fn, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doParallel" id="apidoc.element.async.doParallel">
        function <span class="apidocSignatureSpan">async.</span>doParallel
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallel(fn) {
    return function (obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doParallelLimit" id="apidoc.element.async.doParallelLimit">
        function <span class="apidocSignatureSpan">async.</span>doParallelLimit
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doSeries" id="apidoc.element.async.doSeries">
        function <span class="apidocSignatureSpan">async.</span>doSeries
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doSeries(fn) {
    return function (obj, iteratee, callback) {
        return fn(_eachOfSeries2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doUntil" id="apidoc.element.async.doUntil">
        function <span class="apidocSignatureSpan">async.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function () {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doWhilst" id="apidoc.element.async.doWhilst">
        function <span class="apidocSignatureSpan">async.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.during" id="apidoc.element.async.during">
        function <span class="apidocSignatureSpan">async.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.each" id="apidoc.element.async.each">
        function <span class="apidocSignatureSpan">async.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachLimit" id="apidoc.element.async.eachLimit">
        function <span class="apidocSignatureSpan">async.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOf" id="apidoc.element.async.eachOf">
        function <span class="apidocSignatureSpan">async.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOfLimit" id="apidoc.element.async.eachOfLimit">
        function <span class="apidocSignatureSpan">async.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOfSeries" id="apidoc.element.async.eachOfSeries">
        function <span class="apidocSignatureSpan">async.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachSeries" id="apidoc.element.async.eachSeries">
        function <span class="apidocSignatureSpan">async.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.ensureAsync" id="apidoc.element.async.ensureAsync">
        function <span class="apidocSignatureSpan">async.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.<span class="apidocCodeKeywordSpan">ensureAsync</span>(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
return (0, _initialParams2.default)(function (args, callback) {
    var sync = true;
    args.push(function () {
        var innerArgs = arguments;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.every" id="apidoc.element.async.every">
        function <span class="apidocSignatureSpan">async.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.everyLimit" id="apidoc.element.async.everyLimit">
        function <span class="apidocSignatureSpan">async.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.everySeries" id="apidoc.element.async.everySeries">
        function <span class="apidocSignatureSpan">async.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filter" id="apidoc.element.async.filter">
        function <span class="apidocSignatureSpan">async.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filterLimit" id="apidoc.element.async.filterLimit">
        function <span class="apidocSignatureSpan">async.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filterSeries" id="apidoc.element.async.filterSeries">
        function <span class="apidocSignatureSpan">async.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.find" id="apidoc.element.async.find">
        function <span class="apidocSignatureSpan">async.</span>find
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.findGetResult" id="apidoc.element.async.findGetResult">
        function <span class="apidocSignatureSpan">async.</span>findGetResult
        <span class="apidocSignatureSpan">(v, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _findGetResult(v, x) {
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.findLimit" id="apidoc.element.async.findLimit">
        function <span class="apidocSignatureSpan">async.</span>findLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.findSeries" id="apidoc.element.async.findSeries">
        function <span class="apidocSignatureSpan">async.</span>findSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.foldl" id="apidoc.element.async.foldl">
        function <span class="apidocSignatureSpan">async.</span>foldl
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.foldr" id="apidoc.element.async.foldr">
        function <span class="apidocSignatureSpan">async.</span>foldr
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEach" id="apidoc.element.async.forEach">
        function <span class="apidocSignatureSpan">async.</span>forEach
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachLimit" id="apidoc.element.async.forEachLimit">
        function <span class="apidocSignatureSpan">async.</span>forEachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOf" id="apidoc.element.async.forEachOf">
        function <span class="apidocSignatureSpan">async.</span>forEachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called when all
* `iteratee` functions have finished, or an error occurs. Invoked with (err).
* @example
*
* var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
* var configs = {};
*
* async.<span class="apidocCodeKeywordSpan">forEachOf</span>(obj, function (value, key, callback) {
*     fs.readFile(__dirname + value, "utf8", function (err, data) {
*         if (err) return callback(err);
*         try {
*             configs[key] = JSON.parse(data);
*         } catch (e) {
*             return callback(e);
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOfLimit" id="apidoc.element.async.forEachOfLimit">
        function <span class="apidocSignatureSpan">async.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOfSeries" id="apidoc.element.async.forEachOfSeries">
        function <span class="apidocSignatureSpan">async.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachSeries" id="apidoc.element.async.forEachSeries">
        function <span class="apidocSignatureSpan">async.</span>forEachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forever" id="apidoc.element.async.forever">
        function <span class="apidocSignatureSpan">async.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync$1(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it's callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as 'err', and execution will stop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.getIterator" id="apidoc.element.async.getIterator">
        function <span class="apidocSignatureSpan">async.</span>getIterator
        <span class="apidocSignatureSpan">(coll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIterator = function (coll) {
    return iteratorSymbol &amp;&amp; coll[iteratorSymbol] &amp;&amp; coll[iteratorSymbol]();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupBy" id="apidoc.element.async.groupBy">
        function <span class="apidocSignatureSpan">async.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(['userId1', 'userId2', 'userId3'], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupByLimit" id="apidoc.element.async.groupByLimit">
        function <span class="apidocSignatureSpan">async.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync$1(iteratee);
    mapLimit(coll, limit, function (val, callback) {
        _iteratee(val, function (err, key) {
            if (err) return callback(err);
            return callback(null, { key: key, val: val });
        });
    }, function (err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupBySeries" id="apidoc.element.async.groupBySeries">
        function <span class="apidocSignatureSpan">async.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.initialParams" id="apidoc.element.async.initialParams">
        function <span class="apidocSignatureSpan">async.</span>initialParams
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialParams = function (fn) {
    return (0, _rest2.default)(function (args /*..., callback*/) {
        var callback = args.pop();
        fn.call(this, args, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.inject" id="apidoc.element.async.inject">
        function <span class="apidocSignatureSpan">async.</span>inject
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.iterator" id="apidoc.element.async.iterator">
        function <span class="apidocSignatureSpan">async.</span>iterator
        <span class="apidocSignatureSpan">(coll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.log" id="apidoc.element.async.log">
        function <span class="apidocSignatureSpan">async.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
*
* async.auto({
*     get_data: function(callback) {
*         console.<span class="apidocCodeKeywordSpan">log</span>('in get_data');
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         console.log('in make_folder');
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.map" id="apidoc.element.async.map">
        function <span class="apidocSignatureSpan">async.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, '');
   func = func.match(FN_ARGS)[2].replace(' ', '');
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, ''));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapLimit" id="apidoc.element.async.mapLimit">
        function <span class="apidocSignatureSpan">async.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapSeries" id="apidoc.element.async.mapSeries">
        function <span class="apidocSignatureSpan">async.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValues" id="apidoc.element.async.mapValues">
        function <span class="apidocSignatureSpan">async.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: 'file1',
*     f2: 'file2',
*     f3: 'file3'
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValuesLimit" id="apidoc.element.async.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync$1(iteratee);
    eachOfLimit(obj, limit, function (val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValuesSeries" id="apidoc.element.async.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.memoize" id="apidoc.element.async.memoize">
        function <span class="apidocSignatureSpan">async.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync$1(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function () {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(rest(function (args) {
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            })));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.nextTick" id="apidoc.element.async.nextTick">
        function <span class="apidocSignatureSpan">async.</span>nextTick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} callback - The function to call on a later loop around
* the event loop. Invoked with (args...).
* @param {...*} args... - any number of additional arguments to pass to the
* callback on the next tick.
* @example
*
* var call_order = [];
* async.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
*     call_order.push('two');
*     // call_order now equals ['one','two']
* });
* call_order.push('one');
*
* async.setImmediate(function (a, b, c) {
*     // a, b, and c equal 1, 2, and 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.notId" id="apidoc.element.async.notId">
        function <span class="apidocSignatureSpan">async.</span>notId
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notId(v) {
    return !v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.once" id="apidoc.element.async.once">
        function <span class="apidocSignatureSpan">async.</span>once
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.onlyOnce" id="apidoc.element.async.onlyOnce">
        function <span class="apidocSignatureSpan">async.</span>onlyOnce
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.parallel" id="apidoc.element.async.parallel">
        function <span class="apidocSignatureSpan">async.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
  _parallel(eachOf, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} function - The function you want to eventually apply all
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.parallelLimit" id="apidoc.element.async.parallelLimit">
        function <span class="apidocSignatureSpan">async.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit$1(tasks, limit, callback) {
  _parallel(_eachOfLimit(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.priorityQueue" id="apidoc.element.async.priorityQueue">
        function <span class="apidocSignatureSpan">async.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function () {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.queue" id="apidoc.element.async.queue">
        function <span class="apidocSignatureSpan">async.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
  var _worker = wrapAsync$1(worker);
  return queue(function (items, cb) {
    _worker(items[0], cb);
  }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.race" id="apidoc.element.async.race">
        function <span class="apidocSignatureSpan">async.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        wrapAsync$1(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

/**
* Runs the `tasks` array of functions in parallel, without waiting until the
* previous function has completed. Once any of the `tasks` complete or pass an
* error to its callback, the main `callback` is immediately called. It's
* equivalent to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`.
*
* @name race
* @static
* @memberOf module:ControlFlow
* @method
* @category Control Flow
* @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reduce" id="apidoc.element.async.reduce">
        function <span class="apidocSignatureSpan">async.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reduceRight" id="apidoc.element.async.reduceRight">
        function <span class="apidocSignatureSpan">async.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reflect" id="apidoc.element.async.reflect">
        function <span class="apidocSignatureSpan">async.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = wrapAsync$1(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(rest(function callback(err, cbArgs) {
            if (err) {
                reflectCallback(null, {
                    error: err
                });
            } else {
                var value = null;
                if (cbArgs.length === 1) {
                    value = cbArgs[0];
                } else if (cbArgs.length &gt; 1) {
                    value = cbArgs;
                }
                reflectCallback(null, {
                    value: value
                });
            }
        }));

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {AsyncFunction} fn - The async function you want to wrap
* @returns {Function} - A function that always passes null to it's callback as
* the error. The second argument to the callback will be an `object` with
* either an `error` or a `value` property.
* @example
*
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">reflect</span>(function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     }),
*     async.reflect(function(callback) {
*         // do some more stuff but error ...
*         callback('bad stuff happened');
*     }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reflectAll" id="apidoc.element.async.reflectAll">
        function <span class="apidocSignatureSpan">async.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function (task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, 'two');
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = 'one'
*     // results[1].error = Error('bad stuff happened')
*     // results[2].value = 'two'
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reject" id="apidoc.element.async.reject">
        function <span class="apidocSignatureSpan">async.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.rejectLimit" id="apidoc.element.async.rejectLimit">
        function <span class="apidocSignatureSpan">async.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.rejectSeries" id="apidoc.element.async.rejectSeries">
        function <span class="apidocSignatureSpan">async.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.rest" id="apidoc.element.async.rest">
        function <span class="apidocSignatureSpan">async.</span>rest
        <span class="apidocSignatureSpan">(func, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rest(func, start) {
    return (0, _overRest3.default)(func, start, _identity2.default);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.retry" id="apidoc.element.async.retry">
        function <span class="apidocSignatureSpan">async.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync$1(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp; (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.retryable" id="apidoc.element.async.retryable">
        function <span class="apidocSignatureSpan">async.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync$1(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     // do something with the result
 * });
 *
 * // It can also be embedded within other control flow functions to retry
 * // individual methods that are not as reliable, like this:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
var DEFAULT_TIMES = 5;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.select" id="apidoc.element.async.select">
        function <span class="apidocSignatureSpan">async.</span>select
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.selectLimit" id="apidoc.element.async.selectLimit">
        function <span class="apidocSignatureSpan">async.</span>selectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.selectSeries" id="apidoc.element.async.selectSeries">
        function <span class="apidocSignatureSpan">async.</span>selectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.seq" id="apidoc.element.async.seq">
        function <span class="apidocSignatureSpan">async.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seq = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende's orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get('/cats', function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.series" id="apidoc.element.async.series">
        function <span class="apidocSignatureSpan">async.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  _parallel(eachOfSeries, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, 'two');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.setImmediate" id="apidoc.element.async.setImmediate">
        function <span class="apidocSignatureSpan">async.</span>setImmediate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.some" id="apidoc.element.async.some">
        function <span class="apidocSignatureSpan">async.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.someLimit" id="apidoc.element.async.someLimit">
        function <span class="apidocSignatureSpan">async.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.someSeries" id="apidoc.element.async.someSeries">
        function <span class="apidocSignatureSpan">async.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.sortBy" id="apidoc.element.async.sortBy">
        function <span class="apidocSignatureSpan">async.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = wrapAsync$1(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, { value: x, criteria: criteria });
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria,
            b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(['file1','file2','file3'], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timeout" id="apidoc.element.async.timeout">
        function <span class="apidocSignatureSpan">async.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var originalCallback, timer;
    var timedOut = false;

    function injectedCallback() {
        if (!timedOut) {
            originalCallback.apply(null, arguments);
            clearTimeout(timer);
        }
    }

    function timeoutCallback() {
        var name = asyncFn.name || 'anonymous';
        var error = new Error('Callback function "' + name + '" timed out.');
        error.code = 'ETIMEDOUT';
        if (info) {
            error.info = info;
        }
        timedOut = true;
        originalCallback(error);
    }

    var fn = wrapAsync$1(asyncFn);

    return initialParams(function (args, origCallback) {
        originalCallback = origCallback;
        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args.concat(injectedCallback));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: 'bar' }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code 'ETIMEDOUT'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.times" id="apidoc.element.async.times">
        function <span class="apidocSignatureSpan">async.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: 'user' + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timesLimit" id="apidoc.element.async.timesLimit">
        function <span class="apidocSignatureSpan">async.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync$1(iteratee);
  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timesSeries" id="apidoc.element.async.timesSeries">
        function <span class="apidocSignatureSpan">async.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.transform" id="apidoc.element.async.transform">
        function <span class="apidocSignatureSpan">async.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);

    eachOf(coll, function (v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function (err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.unmemoize" id="apidoc.element.async.unmemoize">
        function <span class="apidocSignatureSpan">async.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.until" id="apidoc.element.async.until">
        function <span class="apidocSignatureSpan">async.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    whilst(function () {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.waterfall" id="apidoc.element.async.waterfall">
        function <span class="apidocSignatureSpan">async.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        if (taskIndex === tasks.length) {
            return callback.apply(null, [null].concat(args));
        }

        var taskCallback = onlyOnce(rest(function (err, args) {
            if (err) {
                return callback.apply(null, [err].concat(args));
            }
            nextTask(args);
        }));

        args.push(taskCallback);

        var task = wrapAsync$1(tasks[taskIndex++]);
        task.apply(null, args);
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous funuction, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.whilst" id="apidoc.element.async.whilst">
        function <span class="apidocSignatureSpan">async.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    if (!test()) return callback(null);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`'s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.withoutIndex" id="apidoc.element.async.withoutIndex">
        function <span class="apidocSignatureSpan">async.</span>withoutIndex
        <span class="apidocSignatureSpan">(iteratee)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.wrapSync" id="apidoc.element.async.wrapSync">
        function <span class="apidocSignatureSpan">async.</span>wrapSync
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === 'function') {
            result.then(function (value) {
                callback(null, value);
            }, function (err) {
                callback(err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.DoublyLinkedList" id="apidoc.module.async.DoublyLinkedList">module async.DoublyLinkedList</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.DoublyLinkedList" id="apidoc.element.async.DoublyLinkedList.DoublyLinkedList">
        function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.DoublyLinkedList.prototype" id="apidoc.module.async.DoublyLinkedList.prototype">module async.DoublyLinkedList.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.empty" id="apidoc.element.async.DoublyLinkedList.prototype.empty">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
started: false,
paused: false,
push: function (data, callback) {
    _insert(data, false, callback);
},
kill: function () {
    q.drain = _noop2.default;
    q._tasks.<span class="apidocCodeKeywordSpan">empty</span>();
},
unshift: function (data, callback) {
    _insert(data, true, callback);
},
process: function () {
    // Avoid trying to start too many processing operations. This can occur
    // when callbacks resolve synchronously (#1267).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.insertAfter" id="apidoc.element.async.DoublyLinkedList.prototype.insertAfter">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(node, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

DLL.prototype.unshift = function (node) {
    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
};

DLL.prototype.push = function (node) {
    if (this.tail) this.<span class="apidocCodeKeywordSpan">insertAfter</span>(this.tail, node);else setInitial(this, node);
};

DLL.prototype.shift = function () {
    return this.head &amp;&amp; this.removeLink(this.head);
};

DLL.prototype.pop = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.insertBefore" id="apidoc.element.async.DoublyLinkedList.prototype.insertBefore">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(node, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
};

DLL.prototype.unshift = function (node) {
    if (this.head) this.<span class="apidocCodeKeywordSpan">insertBefore</span>(this.head, node);else setInitial(this, node);
};

DLL.prototype.push = function (node) {
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
};

DLL.prototype.shift = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.pop" id="apidoc.element.async.DoublyLinkedList.prototype.pop">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
    return this.tail &amp;&amp; this.removeLink(this.tail);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    function checkForDeadlocks() {
// Kahn's algorithm
// https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
// http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
var currentTask;
var counter = 0;
while (readyToCheck.length) {
    currentTask = readyToCheck.<span class="apidocCodeKeywordSpan">pop</span>();
    counter++;
    (0, _arrayEach2.default)(getDependents(currentTask), function (dependent) {
        if (--uncheckedDependencies[dependent] === 0) {
            readyToCheck.push(dependent);
        }
    });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.push" id="apidoc.element.async.DoublyLinkedList.prototype.push">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (node) {
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.<span class="apidocCodeKeywordSpan">push</span>(files);
 */
function asyncify(func) {
return (0, _initialParams2.default)(function (args, callback) {
    var result;
    try {
        result = func.apply(this, args);
    } catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.removeLink" id="apidoc.element.async.DoublyLinkedList.prototype.removeLink">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>removeLink
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeLink = function (node) {
    if (node.prev) node.prev.next = node.next;else this.head = node.next;
    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

DLL.prototype.push = function (node) {
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
};

DLL.prototype.shift = function () {
    return this.head &amp;&amp; this.<span class="apidocCodeKeywordSpan">removeLink</span>(this.head);
};

DLL.prototype.pop = function () {
    return this.tail &amp;&amp; this.removeLink(this.tail);
};
module.exports = exports["default"];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.shift" id="apidoc.element.async.DoublyLinkedList.prototype.shift">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
    return this.head &amp;&amp; this.removeLink(this.head);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function processQueue() {
    if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
        return callback(null, results);
    }
    while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
        var run = readyTasks.<span class="apidocCodeKeywordSpan">shift</span>();
        run();
    }
}

function addListener(taskName, fn) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.unshift" id="apidoc.element.async.DoublyLinkedList.prototype.unshift">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (node) {
    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0, l = data.length; i &lt; l; i++) {
        var item = {
            data: data[i],
            callback: callback || _noop2.default
        };

        if (insertAtFront) {
            q._tasks.<span class="apidocCodeKeywordSpan">unshift</span>(item);
        } else {
            q._tasks.push(item);
        }
    }
    (0, _setImmediate2.default)(q.process);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.apply" id="apidoc.module.async.apply">module async.apply</a></h1>


    <h2>
        <a href="#apidoc.element.async.apply.apply" id="apidoc.element.async.apply.apply">
        function <span class="apidocSignatureSpan">async.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">apply</span>(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
*     function(callback) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.apply.apply" id="apidoc.module.async.apply.apply">module async.apply.apply</a></h1>


    <h2>
        <a href="#apidoc.element.async.apply.apply.apply" id="apidoc.element.async.apply.apply.apply">
        function <span class="apidocSignatureSpan">async.apply.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function apply() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">apply</span>(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
*     function(callback) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.applyEach" id="apidoc.module.async.applyEach">module async.applyEach</a></h1>


    <h2>
        <a href="#apidoc.element.async.applyEach.applyEach" id="apidoc.element.async.applyEach.applyEach">
        function <span class="apidocSignatureSpan">async.</span>applyEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], 'bucket', callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.applyEachSeries" id="apidoc.module.async.applyEachSeries">module async.applyEachSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.applyEachSeries.applyEachSeries" id="apidoc.element.async.applyEachSeries.applyEachSeries">
        function <span class="apidocSignatureSpan">async.</span>applyEachSeries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.asyncify" id="apidoc.module.async.asyncify">module async.asyncify</a></h1>


    <h2>
        <a href="#apidoc.element.async.asyncify.asyncify" id="apidoc.element.async.asyncify.asyncify">
        function <span class="apidocSignatureSpan">async.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === 'function') {
            result.then(function (value) {
                callback(null, value);
            }, function (err) {
                callback(err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.auto" id="apidoc.module.async.auto">module async.auto</a></h1>


    <h2>
        <a href="#apidoc.element.async.auto.auto" id="apidoc.element.async.auto.auto">
        function <span class="apidocSignatureSpan">async.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies
.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }
    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }

    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(rest(function (err, args) {
            runningTasks--;
            if (args.length &lt;= 1) {
                args = args[0];
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function (val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = args;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = args;
                taskComplete(key);
            }
        }));

        runningTasks++;
        var taskFn = wrapAsync$1(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function ( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
*     showData: ['readData', function(results, cb) {
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.autoInject" id="apidoc.module.async.autoInject">module async.autoInject</a></h1>


    <h2>
        <a href="#apidoc.element.async.autoInject.autoInject" id="apidoc.element.async.autoInject.autoInject">
        function <span class="apidocSignatureSpan">async.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync &amp;&amp; taskFn.length === 1 || fnIsAsync &amp;&amp; taskFn.length === 0;

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync$1(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.cargo" id="apidoc.module.async.cargo">module async.cargo</a></h1>


    <h2>
        <a href="#apidoc.element.async.cargo.cargo" id="apidoc.element.async.cargo.cargo">
        function <span class="apidocSignatureSpan">async.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return queue(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log('hello ' + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.compose" id="apidoc.module.async.compose">module async.compose</a></h1>


    <h2>
        <a href="#apidoc.element.async.compose.compose" id="apidoc.element.async.compose.compose">
        function <span class="apidocSignatureSpan">async.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
exports.default = (0, _rest2.default)(function (args) {
  return _seq2.default.apply(null, args.reverse());
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.concat" id="apidoc.module.async.concat">module async.concat</a></h1>


    <h2>
        <a href="#apidoc.element.async.concat.concat" id="apidoc.element.async.concat.concat">
        function <span class="apidocSignatureSpan">async.</span>concat
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * node&gt; fn('two', 'three');
 * one
 * two
 * three
 */
exports.default = (0, _rest2.default)(function (fn, args) {
    return (0, _rest2.default)(function (callArgs) {
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    });
});
module.exports = exports['default'];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.concatSeries" id="apidoc.module.async.concatSeries">module async.concatSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.concatSeries.concatSeries" id="apidoc.element.async.concatSeries.concatSeries">
        function <span class="apidocSignatureSpan">async.</span>concatSeries
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (obj, iteratee, callback) {
    return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.consoleFunc" id="apidoc.module.async.consoleFunc">module async.consoleFunc</a></h1>


    <h2>
        <a href="#apidoc.element.async.consoleFunc.consoleFunc" id="apidoc.element.async.consoleFunc.consoleFunc">
        function <span class="apidocSignatureSpan">async.</span>consoleFunc
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function consoleFunc(name) {
    return (0, _rest2.default)(function (fn, args) {
        (0, _wrapAsync2.default)(fn).apply(null, args.concat((0, _rest2.default)(function (err, args) {
            if (typeof console === 'object') {
                if (err) {
                    if (console.error) {
                        console.error(err);
                    }
                } else if (console[name]) {
                    (0, _arrayEach2.default)(args, function (x) {
                        console[name](x);
                    });
                }
            }
        })));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.constant" id="apidoc.module.async.constant">module async.constant</a></h1>


    <h2>
        <a href="#apidoc.element.async.constant.constant" id="apidoc.element.async.constant.constant">
        function <span class="apidocSignatureSpan">async.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.createTester" id="apidoc.module.async.createTester">module async.createTester</a></h1>


    <h2>
        <a href="#apidoc.element.async.createTester.createTester" id="apidoc.element.async.createTester.createTester">
        function <span class="apidocSignatureSpan">async.</span>createTester
        <span class="apidocSignatureSpan">(check, getResult)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _createTester(check, getResult) {
    return function (eachfn, arr, iteratee, cb) {
        cb = cb || _noop2.default;
        var testPassed = false;
        var testResult;
        eachfn(arr, function (value, _, callback) {
            iteratee(value, function (err, result) {
                if (err) {
                    callback(err);
                } else if (check(result) &amp;&amp; !testResult) {
                    testPassed = true;
                    testResult = getResult(true, value);
                    callback(null, _breakLoop2.default);
                } else {
                    callback();
                }
            });
        }, function (err) {
            if (err) {
                cb(err);
            } else {
                cb(null, testPassed ? testResult : getResult(false));
            }
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.default" id="apidoc.module.async.default">module async.default</a></h1>


    <h2>
        <a href="#apidoc.element.async.default.all" id="apidoc.element.async.default.all">
        function <span class="apidocSignatureSpan">async.default.</span>all
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.any" id="apidoc.element.async.default.any">
        function <span class="apidocSignatureSpan">async.default.</span>any
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.apply" id="apidoc.element.async.default.apply">
        function <span class="apidocSignatureSpan">async.default.</span>apply
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">apply</span>(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
*     function(callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.applyEach" id="apidoc.element.async.default.applyEach">
        function <span class="apidocSignatureSpan">async.default.</span>applyEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], 'bucket', callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.applyEachSeries" id="apidoc.element.async.default.applyEachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>applyEachSeries
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.asyncify" id="apidoc.element.async.default.asyncify">
        function <span class="apidocSignatureSpan">async.default.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === 'function') {
            result.then(function (value) {
                callback(null, value);
            }, function (err) {
                callback(err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.auto" id="apidoc.element.async.default.auto">
        function <span class="apidocSignatureSpan">async.default.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === 'function') {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies
.join(', '));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }
    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }

    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(rest(function (err, args) {
            runningTasks--;
            if (args.length &lt;= 1) {
                args = args[0];
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function (val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = args;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = args;
                taskComplete(key);
            }
        }));

        runningTasks++;
        var taskFn = wrapAsync$1(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn's algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;
        while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            arrayEach(getDependents(currentTask), function ( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
*     showData: ['readData', function(results, cb) {
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.autoInject" id="apidoc.element.async.default.autoInject">
        function <span class="apidocSignatureSpan">async.default.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps = !fnIsAsync &amp;&amp; taskFn.length === 1 || fnIsAsync &amp;&amp; taskFn.length === 0;

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync$1(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.cargo" id="apidoc.element.async.default.cargo">
        function <span class="apidocSignatureSpan">async.default.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return queue(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log('hello ' + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.compose" id="apidoc.element.async.default.compose">
        function <span class="apidocSignatureSpan">async.default.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
exports.default = (0, _rest2.default)(function (args) {
  return _seq2.default.apply(null, args.reverse());
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.concat" id="apidoc.element.async.default.concat">
        function <span class="apidocSignatureSpan">async.default.</span>concat
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * node&gt; fn('two', 'three');
 * one
 * two
 * three
 */
exports.default = (0, _rest2.default)(function (fn, args) {
    return (0, _rest2.default)(function (callArgs) {
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    });
});
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.concatSeries" id="apidoc.element.async.default.concatSeries">
        function <span class="apidocSignatureSpan">async.default.</span>concatSeries
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (obj, iteratee, callback) {
    return fn(eachOfSeries, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.constant" id="apidoc.element.async.default.constant">
        function <span class="apidocSignatureSpan">async.default.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detect" id="apidoc.element.async.default.detect">
        function <span class="apidocSignatureSpan">async.default.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detectLimit" id="apidoc.element.async.default.detectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detectSeries" id="apidoc.element.async.default.detectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.dir" id="apidoc.element.async.default.dir">
        function <span class="apidocSignatureSpan">async.default.</span>dir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, 'world');
 * {hello: 'world'}
 */
exports.default = (0, _consoleFunc2.default)('dir');
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doDuring" id="apidoc.element.async.default.doDuring">
        function <span class="apidocSignatureSpan">async.default.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    var next = rest(function (err, args) {
        if (err) return callback(err);
        args.push(check);
        _test.apply(this, args);
    });

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doUntil" id="apidoc.element.async.default.doUntil">
        function <span class="apidocSignatureSpan">async.default.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function () {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doWhilst" id="apidoc.element.async.default.doWhilst">
        function <span class="apidocSignatureSpan">async.default.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.during" id="apidoc.element.async.default.during">
        function <span class="apidocSignatureSpan">async.default.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.each" id="apidoc.element.async.default.each">
        function <span class="apidocSignatureSpan">async.default.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports['default'];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachLimit" id="apidoc.element.async.default.eachLimit">
        function <span class="apidocSignatureSpan">async.default.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOf" id="apidoc.element.async.default.eachOf">
        function <span class="apidocSignatureSpan">async.default.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOfLimit" id="apidoc.element.async.default.eachOfLimit">
        function <span class="apidocSignatureSpan">async.default.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOfSeries" id="apidoc.element.async.default.eachOfSeries">
        function <span class="apidocSignatureSpan">async.default.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachSeries" id="apidoc.element.async.default.eachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.ensureAsync" id="apidoc.element.async.default.ensureAsync">
        function <span class="apidocSignatureSpan">async.default.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.<span class="apidocCodeKeywordSpan">ensureAsync</span>(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
return (0, _initialParams2.default)(function (args, callback) {
    var sync = true;
    args.push(function () {
        var innerArgs = arguments;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.every" id="apidoc.element.async.default.every">
        function <span class="apidocSignatureSpan">async.default.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.everyLimit" id="apidoc.element.async.default.everyLimit">
        function <span class="apidocSignatureSpan">async.default.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.everySeries" id="apidoc.element.async.default.everySeries">
        function <span class="apidocSignatureSpan">async.default.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filter" id="apidoc.element.async.default.filter">
        function <span class="apidocSignatureSpan">async.default.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filterLimit" id="apidoc.element.async.default.filterLimit">
        function <span class="apidocSignatureSpan">async.default.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filterSeries" id="apidoc.element.async.default.filterSeries">
        function <span class="apidocSignatureSpan">async.default.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.foldl" id="apidoc.element.async.default.foldl">
        function <span class="apidocSignatureSpan">async.default.</span>foldl
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.foldr" id="apidoc.element.async.default.foldr">
        function <span class="apidocSignatureSpan">async.default.</span>foldr
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEach" id="apidoc.element.async.default.forEach">
        function <span class="apidocSignatureSpan">async.default.</span>forEach
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachLimit" id="apidoc.element.async.default.forEachLimit">
        function <span class="apidocSignatureSpan">async.default.</span>forEachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOf" id="apidoc.element.async.default.forEachOf">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called when all
* `iteratee` functions have finished, or an error occurs. Invoked with (err).
* @example
*
* var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
* var configs = {};
*
* async.<span class="apidocCodeKeywordSpan">forEachOf</span>(obj, function (value, key, callback) {
*     fs.readFile(__dirname + value, "utf8", function (err, data) {
*         if (err) return callback(err);
*         try {
*             configs[key] = JSON.parse(data);
*         } catch (e) {
*             return callback(e);
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOfLimit" id="apidoc.element.async.default.forEachOfLimit">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOfSeries" id="apidoc.element.async.default.forEachOfSeries">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachSeries" id="apidoc.element.async.default.forEachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>forEachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forever" id="apidoc.element.async.default.forever">
        function <span class="apidocSignatureSpan">async.default.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync$1(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it's callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as 'err', and execution will stop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupBy" id="apidoc.element.async.default.groupBy">
        function <span class="apidocSignatureSpan">async.default.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(['userId1', 'userId2', 'userId3'], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupByLimit" id="apidoc.element.async.default.groupByLimit">
        function <span class="apidocSignatureSpan">async.default.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync$1(iteratee);
    mapLimit(coll, limit, function (val, callback) {
        _iteratee(val, function (err, key) {
            if (err) return callback(err);
            return callback(null, { key: key, val: val });
        });
    }, function (err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupBySeries" id="apidoc.element.async.default.groupBySeries">
        function <span class="apidocSignatureSpan">async.default.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.inject" id="apidoc.element.async.default.inject">
        function <span class="apidocSignatureSpan">async.default.</span>inject
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.log" id="apidoc.element.async.default.log">
        function <span class="apidocSignatureSpan">async.default.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
*
* async.auto({
*     get_data: function(callback) {
*         console.<span class="apidocCodeKeywordSpan">log</span>('in get_data');
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         console.log('in make_folder');
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.map" id="apidoc.element.async.default.map">
        function <span class="apidocSignatureSpan">async.default.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, '');
   func = func.match(FN_ARGS)[2].replace(' ', '');
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, ''));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapLimit" id="apidoc.element.async.default.mapLimit">
        function <span class="apidocSignatureSpan">async.default.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapSeries" id="apidoc.element.async.default.mapSeries">
        function <span class="apidocSignatureSpan">async.default.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValues" id="apidoc.element.async.default.mapValues">
        function <span class="apidocSignatureSpan">async.default.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: 'file1',
*     f2: 'file2',
*     f3: 'file3'
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValuesLimit" id="apidoc.element.async.default.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.default.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync$1(iteratee);
    eachOfLimit(obj, limit, function (val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValuesSeries" id="apidoc.element.async.default.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.default.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.memoize" id="apidoc.element.async.default.memoize">
        function <span class="apidocSignatureSpan">async.default.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync$1(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function () {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(rest(function (args) {
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            })));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.nextTick" id="apidoc.element.async.default.nextTick">
        function <span class="apidocSignatureSpan">async.default.</span>nextTick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} callback - The function to call on a later loop around
* the event loop. Invoked with (args...).
* @param {...*} args... - any number of additional arguments to pass to the
* callback on the next tick.
* @example
*
* var call_order = [];
* async.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
*     call_order.push('two');
*     // call_order now equals ['one','two']
* });
* call_order.push('one');
*
* async.setImmediate(function (a, b, c) {
*     // a, b, and c equal 1, 2, and 3
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.parallel" id="apidoc.element.async.default.parallel">
        function <span class="apidocSignatureSpan">async.default.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
  _parallel(eachOf, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} function - The function you want to eventually apply all
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.parallelLimit" id="apidoc.element.async.default.parallelLimit">
        function <span class="apidocSignatureSpan">async.default.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit$1(tasks, limit, callback) {
  _parallel(_eachOfLimit(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.priorityQueue" id="apidoc.element.async.default.priorityQueue">
        function <span class="apidocSignatureSpan">async.default.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function () {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.queue" id="apidoc.element.async.default.queue">
        function <span class="apidocSignatureSpan">async.default.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
  var _worker = wrapAsync$1(worker);
  return queue(function (items, cb) {
    _worker(items[0], cb);
  }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.race" id="apidoc.element.async.default.race">
        function <span class="apidocSignatureSpan">async.default.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        wrapAsync$1(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

/**
* Runs the `tasks` array of functions in parallel, without waiting until the
* previous function has completed. Once any of the `tasks` complete or pass an
* error to its callback, the main `callback` is immediately called. It's
* equivalent to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`.
*
* @name race
* @static
* @memberOf module:ControlFlow
* @method
* @category Control Flow
* @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reduce" id="apidoc.element.async.default.reduce">
        function <span class="apidocSignatureSpan">async.default.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reduceRight" id="apidoc.element.async.default.reduceRight">
        function <span class="apidocSignatureSpan">async.default.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reflect" id="apidoc.element.async.default.reflect">
        function <span class="apidocSignatureSpan">async.default.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = wrapAsync$1(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(rest(function callback(err, cbArgs) {
            if (err) {
                reflectCallback(null, {
                    error: err
                });
            } else {
                var value = null;
                if (cbArgs.length === 1) {
                    value = cbArgs[0];
                } else if (cbArgs.length &gt; 1) {
                    value = cbArgs;
                }
                reflectCallback(null, {
                    value: value
                });
            }
        }));

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {AsyncFunction} fn - The async function you want to wrap
* @returns {Function} - A function that always passes null to it's callback as
* the error. The second argument to the callback will be an `object` with
* either an `error` or a `value` property.
* @example
*
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">reflect</span>(function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     }),
*     async.reflect(function(callback) {
*         // do some more stuff but error ...
*         callback('bad stuff happened');
*     }),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reflectAll" id="apidoc.element.async.default.reflectAll">
        function <span class="apidocSignatureSpan">async.default.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function (task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, 'two');
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = 'one'
*     // results[1].error = Error('bad stuff happened')
*     // results[2].value = 'two'
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reject" id="apidoc.element.async.default.reject">
        function <span class="apidocSignatureSpan">async.default.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.rejectLimit" id="apidoc.element.async.default.rejectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.rejectSeries" id="apidoc.element.async.default.rejectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.retry" id="apidoc.element.async.default.retry">
        function <span class="apidocSignatureSpan">async.default.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync$1(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp; (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.retryable" id="apidoc.element.async.default.retryable">
        function <span class="apidocSignatureSpan">async.default.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync$1(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     // do something with the result
 * });
 *
 * // It can also be embedded within other control flow functions to retry
 * // individual methods that are not as reliable, like this:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
var DEFAULT_TIMES = 5;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.select" id="apidoc.element.async.default.select">
        function <span class="apidocSignatureSpan">async.default.</span>select
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.selectLimit" id="apidoc.element.async.default.selectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>selectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.selectSeries" id="apidoc.element.async.default.selectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>selectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.seq" id="apidoc.element.async.default.seq">
        function <span class="apidocSignatureSpan">async.default.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seq = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende's orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get('/cats', function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.series" id="apidoc.element.async.default.series">
        function <span class="apidocSignatureSpan">async.default.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  _parallel(eachOfSeries, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, 'two');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.setImmediate" id="apidoc.element.async.default.setImmediate">
        function <span class="apidocSignatureSpan">async.default.</span>setImmediate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.some" id="apidoc.element.async.default.some">
        function <span class="apidocSignatureSpan">async.default.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.someLimit" id="apidoc.element.async.default.someLimit">
        function <span class="apidocSignatureSpan">async.default.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.someSeries" id="apidoc.element.async.default.someSeries">
        function <span class="apidocSignatureSpan">async.default.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.sortBy" id="apidoc.element.async.default.sortBy">
        function <span class="apidocSignatureSpan">async.default.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = wrapAsync$1(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, { value: x, criteria: criteria });
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria,
            b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(['file1','file2','file3'], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timeout" id="apidoc.element.async.default.timeout">
        function <span class="apidocSignatureSpan">async.default.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var originalCallback, timer;
    var timedOut = false;

    function injectedCallback() {
        if (!timedOut) {
            originalCallback.apply(null, arguments);
            clearTimeout(timer);
        }
    }

    function timeoutCallback() {
        var name = asyncFn.name || 'anonymous';
        var error = new Error('Callback function "' + name + '" timed out.');
        error.code = 'ETIMEDOUT';
        if (info) {
            error.info = info;
        }
        timedOut = true;
        originalCallback(error);
    }

    var fn = wrapAsync$1(asyncFn);

    return initialParams(function (args, origCallback) {
        originalCallback = origCallback;
        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args.concat(injectedCallback));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: 'bar' }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code 'ETIMEDOUT'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.times" id="apidoc.element.async.default.times">
        function <span class="apidocSignatureSpan">async.default.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: 'user' + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timesLimit" id="apidoc.element.async.default.timesLimit">
        function <span class="apidocSignatureSpan">async.default.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync$1(iteratee);
  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timesSeries" id="apidoc.element.async.default.timesSeries">
        function <span class="apidocSignatureSpan">async.default.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.transform" id="apidoc.element.async.default.transform">
        function <span class="apidocSignatureSpan">async.default.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);

    eachOf(coll, function (v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function (err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.unmemoize" id="apidoc.element.async.default.unmemoize">
        function <span class="apidocSignatureSpan">async.default.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.until" id="apidoc.element.async.default.until">
        function <span class="apidocSignatureSpan">async.default.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    whilst(function () {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.waterfall" id="apidoc.element.async.default.waterfall">
        function <span class="apidocSignatureSpan">async.default.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        if (taskIndex === tasks.length) {
            return callback.apply(null, [null].concat(args));
        }

        var taskCallback = onlyOnce(rest(function (err, args) {
            if (err) {
                return callback.apply(null, [err].concat(args));
            }
            nextTask(args);
        }));

        args.push(taskCallback);

        var task = wrapAsync$1(tasks[taskIndex++]);
        task.apply(null, args);
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous funuction, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.whilst" id="apidoc.element.async.default.whilst">
        function <span class="apidocSignatureSpan">async.default.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    if (!test()) return callback(null);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`'s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.wrapSync" id="apidoc.element.async.default.wrapSync">
        function <span class="apidocSignatureSpan">async.default.</span>wrapSync
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === 'function') {
            result.then(function (value) {
                callback(null, value);
            }, function (err) {
                callback(err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.detect" id="apidoc.module.async.detect">module async.detect</a></h1>


    <h2>
        <a href="#apidoc.element.async.detect.detect" id="apidoc.element.async.detect.detect">
        function <span class="apidocSignatureSpan">async.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.detectLimit" id="apidoc.module.async.detectLimit">module async.detectLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.detectLimit.detectLimit" id="apidoc.element.async.detectLimit.detectLimit">
        function <span class="apidocSignatureSpan">async.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.detectSeries" id="apidoc.module.async.detectSeries">module async.detectSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.detectSeries.detectSeries" id="apidoc.element.async.detectSeries.detectSeries">
        function <span class="apidocSignatureSpan">async.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.dir" id="apidoc.module.async.dir">module async.dir</a></h1>


    <h2>
        <a href="#apidoc.element.async.dir.dir" id="apidoc.element.async.dir.dir">
        function <span class="apidocSignatureSpan">async.</span>dir
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, 'world');
 * {hello: 'world'}
 */
exports.default = (0, _consoleFunc2.default)('dir');
module.exports = exports['default'];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doDuring" id="apidoc.module.async.doDuring">module async.doDuring</a></h1>


    <h2>
        <a href="#apidoc.element.async.doDuring.doDuring" id="apidoc.element.async.doDuring.doDuring">
        function <span class="apidocSignatureSpan">async.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    var next = rest(function (err, args) {
        if (err) return callback(err);
        args.push(check);
        _test.apply(this, args);
    });

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doLimit" id="apidoc.module.async.doLimit">module async.doLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.doLimit.doLimit" id="apidoc.element.async.doLimit.doLimit">
        function <span class="apidocSignatureSpan">async.</span>doLimit
        <span class="apidocSignatureSpan">(fn, limit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doLimit(fn, limit) {
    return function (iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doParallel" id="apidoc.module.async.doParallel">module async.doParallel</a></h1>


    <h2>
        <a href="#apidoc.element.async.doParallel.doParallel" id="apidoc.element.async.doParallel.doParallel">
        function <span class="apidocSignatureSpan">async.</span>doParallel
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallel(fn) {
    return function (obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doParallelLimit" id="apidoc.module.async.doParallelLimit">module async.doParallelLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.doParallelLimit.doParallelLimit" id="apidoc.element.async.doParallelLimit.doParallelLimit">
        function <span class="apidocSignatureSpan">async.</span>doParallelLimit
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doParallelLimit(fn) {
    return function (obj, limit, iteratee, callback) {
        return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doSeries" id="apidoc.module.async.doSeries">module async.doSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.doSeries.doSeries" id="apidoc.element.async.doSeries.doSeries">
        function <span class="apidocSignatureSpan">async.</span>doSeries
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doSeries(fn) {
    return function (obj, iteratee, callback) {
        return fn(_eachOfSeries2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doUntil" id="apidoc.module.async.doUntil">module async.doUntil</a></h1>


    <h2>
        <a href="#apidoc.element.async.doUntil.doUntil" id="apidoc.element.async.doUntil.doUntil">
        function <span class="apidocSignatureSpan">async.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function () {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.doWhilst" id="apidoc.module.async.doWhilst">module async.doWhilst</a></h1>


    <h2>
        <a href="#apidoc.element.async.doWhilst.doWhilst" id="apidoc.element.async.doWhilst.doWhilst">
        function <span class="apidocSignatureSpan">async.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.during" id="apidoc.module.async.during">module async.during</a></h1>


    <h2>
        <a href="#apidoc.element.async.during.during" id="apidoc.element.async.during.during">
        function <span class="apidocSignatureSpan">async.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync$1(fn);
    var _test = wrapAsync$1(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.each" id="apidoc.module.async.each">module async.each</a></h1>


    <h2>
        <a href="#apidoc.element.async.each.each" id="apidoc.element.async.each.each">
        function <span class="apidocSignatureSpan">async.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  eachOf(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports['default'];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.eachLimit" id="apidoc.module.async.eachLimit">module async.eachLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.eachLimit.eachLimit" id="apidoc.element.async.eachLimit.eachLimit">
        function <span class="apidocSignatureSpan">async.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync$1(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.eachOf" id="apidoc.module.async.eachOf">module async.eachOf</a></h1>


    <h2>
        <a href="#apidoc.element.async.eachOf.eachOf" id="apidoc.element.async.eachOf.eachOf">
        function <span class="apidocSignatureSpan">async.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.eachOfLimit" id="apidoc.module.async.eachOfLimit">module async.eachOfLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.eachOfLimit.eachOfLimit" id="apidoc.element.async.eachOfLimit.eachOfLimit">
        function <span class="apidocSignatureSpan">async.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  _eachOfLimit(limit)(coll, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.eachOfSeries" id="apidoc.module.async.eachOfSeries">module async.eachOfSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.eachOfSeries.eachOfSeries" id="apidoc.element.async.eachOfSeries.eachOfSeries">
        function <span class="apidocSignatureSpan">async.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.eachSeries" id="apidoc.module.async.eachSeries">module async.eachSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.eachSeries.eachSeries" id="apidoc.element.async.eachSeries.eachSeries">
        function <span class="apidocSignatureSpan">async.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.ensureAsync" id="apidoc.module.async.ensureAsync">module async.ensureAsync</a></h1>


    <h2>
        <a href="#apidoc.element.async.ensureAsync.ensureAsync" id="apidoc.element.async.ensureAsync.ensureAsync">
        function <span class="apidocSignatureSpan">async.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.mapSeries(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.<span class="apidocCodeKeywordSpan">ensureAsync</span>(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
return (0, _initialParams2.default)(function (args, callback) {
    var sync = true;
    args.push(function () {
        var innerArgs = arguments;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.every" id="apidoc.module.async.every">module async.every</a></h1>


    <h2>
        <a href="#apidoc.element.async.every.every" id="apidoc.element.async.every.every">
        function <span class="apidocSignatureSpan">async.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.everyLimit" id="apidoc.module.async.everyLimit">module async.everyLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.everyLimit.everyLimit" id="apidoc.element.async.everyLimit.everyLimit">
        function <span class="apidocSignatureSpan">async.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.everySeries" id="apidoc.module.async.everySeries">module async.everySeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.everySeries.everySeries" id="apidoc.element.async.everySeries.everySeries">
        function <span class="apidocSignatureSpan">async.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.filter" id="apidoc.module.async.filter">module async.filter</a></h1>


    <h2>
        <a href="#apidoc.element.async.filter.filter" id="apidoc.element.async.filter.filter">
        function <span class="apidocSignatureSpan">async.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.filterLimit" id="apidoc.module.async.filterLimit">module async.filterLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.filterLimit.filterLimit" id="apidoc.element.async.filterLimit.filterLimit">
        function <span class="apidocSignatureSpan">async.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.filterSeries" id="apidoc.module.async.filterSeries">module async.filterSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.filterSeries.filterSeries" id="apidoc.element.async.filterSeries.filterSeries">
        function <span class="apidocSignatureSpan">async.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.findGetResult" id="apidoc.module.async.findGetResult">module async.findGetResult</a></h1>


    <h2>
        <a href="#apidoc.element.async.findGetResult.findGetResult" id="apidoc.element.async.findGetResult.findGetResult">
        function <span class="apidocSignatureSpan">async.</span>findGetResult
        <span class="apidocSignatureSpan">(v, x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _findGetResult(v, x) {
    return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.forever" id="apidoc.module.async.forever">module async.forever</a></h1>


    <h2>
        <a href="#apidoc.element.async.forever.forever" id="apidoc.element.async.forever.forever">
        function <span class="apidocSignatureSpan">async.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync$1(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it's callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as 'err', and execution will stop.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.getIterator" id="apidoc.module.async.getIterator">module async.getIterator</a></h1>


    <h2>
        <a href="#apidoc.element.async.getIterator.getIterator" id="apidoc.element.async.getIterator.getIterator">
        function <span class="apidocSignatureSpan">async.</span>getIterator
        <span class="apidocSignatureSpan">(coll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIterator = function (coll) {
    return iteratorSymbol &amp;&amp; coll[iteratorSymbol] &amp;&amp; coll[iteratorSymbol]();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.groupBy" id="apidoc.module.async.groupBy">module async.groupBy</a></h1>


    <h2>
        <a href="#apidoc.element.async.groupBy.groupBy" id="apidoc.element.async.groupBy.groupBy">
        function <span class="apidocSignatureSpan">async.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>(['userId1', 'userId2', 'userId3'], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.groupByLimit" id="apidoc.module.async.groupByLimit">module async.groupByLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.groupByLimit.groupByLimit" id="apidoc.element.async.groupByLimit.groupByLimit">
        function <span class="apidocSignatureSpan">async.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync$1(iteratee);
    mapLimit(coll, limit, function (val, callback) {
        _iteratee(val, function (err, key) {
            if (err) return callback(err);
            return callback(null, { key: key, val: val });
        });
    }, function (err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.groupBySeries" id="apidoc.module.async.groupBySeries">module async.groupBySeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.groupBySeries.groupBySeries" id="apidoc.element.async.groupBySeries.groupBySeries">
        function <span class="apidocSignatureSpan">async.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.initialParams" id="apidoc.module.async.initialParams">module async.initialParams</a></h1>


    <h2>
        <a href="#apidoc.element.async.initialParams.initialParams" id="apidoc.element.async.initialParams.initialParams">
        function <span class="apidocSignatureSpan">async.</span>initialParams
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initialParams = function (fn) {
    return (0, _rest2.default)(function (args /*..., callback*/) {
        var callback = args.pop();
        fn.call(this, args, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.iterator" id="apidoc.module.async.iterator">module async.iterator</a></h1>


    <h2>
        <a href="#apidoc.element.async.iterator.iterator" id="apidoc.element.async.iterator.iterator">
        function <span class="apidocSignatureSpan">async.</span>iterator
        <span class="apidocSignatureSpan">(coll)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function iterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.log" id="apidoc.module.async.log">module async.log</a></h1>


    <h2>
        <a href="#apidoc.element.async.log.log" id="apidoc.element.async.log.log">
        function <span class="apidocSignatureSpan">async.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // results.readData is the file's contents
*         // ...
*     }]
* }, callback);
*
* async.auto({
*     get_data: function(callback) {
*         console.<span class="apidocCodeKeywordSpan">log</span>('in get_data');
*         // async code to get some data
*         callback(null, 'data', 'converted to array');
*     },
*     make_folder: function(callback) {
*         console.log('in make_folder');
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.map" id="apidoc.module.async.map">module async.map</a></h1>


    <h2>
        <a href="#apidoc.element.async.map.map" id="apidoc.element.async.map.map">
        function <span class="apidocSignatureSpan">async.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, '');
   func = func.match(FN_ARGS)[2].replace(' ', '');
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, ''));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.mapLimit" id="apidoc.module.async.mapLimit">module async.mapLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.mapLimit.mapLimit" id="apidoc.element.async.mapLimit.mapLimit">
        function <span class="apidocSignatureSpan">async.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.mapSeries" id="apidoc.module.async.mapSeries">module async.mapSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.mapSeries.mapSeries" id="apidoc.element.async.mapSeries.mapSeries">
        function <span class="apidocSignatureSpan">async.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync's callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.mapValues" id="apidoc.module.async.mapValues">module async.mapValues</a></h1>


    <h2>
        <a href="#apidoc.element.async.mapValues.mapValues" id="apidoc.element.async.mapValues.mapValues">
        function <span class="apidocSignatureSpan">async.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: 'file1',
*     f2: 'file2',
*     f3: 'file3'
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.mapValuesLimit" id="apidoc.module.async.mapValuesLimit">module async.mapValuesLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.mapValuesLimit.mapValuesLimit" id="apidoc.element.async.mapValuesLimit.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync$1(iteratee);
    eachOfLimit(obj, limit, function (val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.mapValuesSeries" id="apidoc.module.async.mapValuesSeries">module async.mapValuesSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.mapValuesSeries.mapValuesSeries" id="apidoc.element.async.mapValuesSeries.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.memoize" id="apidoc.module.async.memoize">module async.memoize</a></h1>


    <h2>
        <a href="#apidoc.element.async.memoize.memoize" id="apidoc.element.async.memoize.memoize">
        function <span class="apidocSignatureSpan">async.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync$1(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function () {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(rest(function (args) {
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            })));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn('some name', function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.nextTick" id="apidoc.module.async.nextTick">module async.nextTick</a></h1>


    <h2>
        <a href="#apidoc.element.async.nextTick.nextTick" id="apidoc.element.async.nextTick.nextTick">
        function <span class="apidocSignatureSpan">async.</span>nextTick
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} callback - The function to call on a later loop around
* the event loop. Invoked with (args...).
* @param {...*} args... - any number of additional arguments to pass to the
* callback on the next tick.
* @example
*
* var call_order = [];
* async.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
*     call_order.push('two');
*     // call_order now equals ['one','two']
* });
* call_order.push('one');
*
* async.setImmediate(function (a, b, c) {
*     // a, b, and c equal 1, 2, and 3
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.notId" id="apidoc.module.async.notId">module async.notId</a></h1>


    <h2>
        <a href="#apidoc.element.async.notId.notId" id="apidoc.element.async.notId.notId">
        function <span class="apidocSignatureSpan">async.</span>notId
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notId(v) {
    return !v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.once" id="apidoc.module.async.once">module async.once</a></h1>


    <h2>
        <a href="#apidoc.element.async.once.once" id="apidoc.element.async.once.once">
        function <span class="apidocSignatureSpan">async.</span>once
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(fn) {
    return function () {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.onlyOnce" id="apidoc.module.async.onlyOnce">module async.onlyOnce</a></h1>


    <h2>
        <a href="#apidoc.element.async.onlyOnce.onlyOnce" id="apidoc.element.async.onlyOnce.onlyOnce">
        function <span class="apidocSignatureSpan">async.</span>onlyOnce
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onlyOnce(fn) {
    return function () {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.parallel" id="apidoc.module.async.parallel">module async.parallel</a></h1>


    <h2>
        <a href="#apidoc.element.async.parallel.parallel" id="apidoc.element.async.parallel.parallel">
        function <span class="apidocSignatureSpan">async.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
  _parallel(eachOf, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} function - The function you want to eventually apply all
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, 'testfile1', 'test1'),
*     async.apply(fs.writeFile, 'testfile2', 'test2')
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.parallelLimit" id="apidoc.module.async.parallelLimit">module async.parallelLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.parallelLimit.parallelLimit" id="apidoc.element.async.parallelLimit.parallelLimit">
        function <span class="apidocSignatureSpan">async.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit$1(tasks, limit, callback) {
  _parallel(_eachOfLimit(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.priorityQueue" id="apidoc.module.async.priorityQueue">module async.priorityQueue</a></h1>


    <h2>
        <a href="#apidoc.element.async.priorityQueue.priorityQueue" id="apidoc.element.async.priorityQueue.priorityQueue">
        function <span class="apidocSignatureSpan">async.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== 'function') {
            throw new Error('task callback must be a function');
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function () {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.queue" id="apidoc.module.async.queue">module async.queue</a></h1>


    <h2>
        <a href="#apidoc.element.async.queue.queue" id="apidoc.element.async.queue.queue">
        function <span class="apidocSignatureSpan">async.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
  var _worker = wrapAsync$1(worker);
  return queue(function (items, cb) {
    _worker(items[0], cb);
  }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.race" id="apidoc.module.async.race">module async.race</a></h1>


    <h2>
        <a href="#apidoc.element.async.race.race" id="apidoc.element.async.race.race">
        function <span class="apidocSignatureSpan">async.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        wrapAsync$1(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

/**
* Runs the `tasks` array of functions in parallel, without waiting until the
* previous function has completed. Once any of the `tasks` complete or pass an
* error to its callback, the main `callback` is immediately called. It's
* equivalent to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`.
*
* @name race
* @static
* @memberOf module:ControlFlow
* @method
* @category Control Flow
* @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.reduce" id="apidoc.module.async.reduce">module async.reduce</a></h1>


    <h2>
        <a href="#apidoc.element.async.reduce.reduce" id="apidoc.element.async.reduce.reduce">
        function <span class="apidocSignatureSpan">async.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    eachOfSeries(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.reduceRight" id="apidoc.module.async.reduceRight">module async.reduceRight</a></h1>


    <h2>
        <a href="#apidoc.element.async.reduceRight.reduceRight" id="apidoc.element.async.reduceRight.reduceRight">
        function <span class="apidocSignatureSpan">async.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = slice.call(array).reverse();
  reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.reflect" id="apidoc.module.async.reflect">module async.reflect</a></h1>


    <h2>
        <a href="#apidoc.element.async.reflect.reflect" id="apidoc.element.async.reflect.reflect">
        function <span class="apidocSignatureSpan">async.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = wrapAsync$1(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(rest(function callback(err, cbArgs) {
            if (err) {
                reflectCallback(null, {
                    error: err
                });
            } else {
                var value = null;
                if (cbArgs.length === 1) {
                    value = cbArgs[0];
                } else if (cbArgs.length &gt; 1) {
                    value = cbArgs;
                }
                reflectCallback(null, {
                    value: value
                });
            }
        }));

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {AsyncFunction} fn - The async function you want to wrap
* @returns {Function} - A function that always passes null to it's callback as
* the error. The second argument to the callback will be an `object` with
* either an `error` or a `value` property.
* @example
*
* async.parallel([
*     async.<span class="apidocCodeKeywordSpan">reflect</span>(function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     }),
*     async.reflect(function(callback) {
*         // do some more stuff but error ...
*         callback('bad stuff happened');
*     }),
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.reflectAll" id="apidoc.module.async.reflectAll">module async.reflectAll</a></h1>


    <h2>
        <a href="#apidoc.element.async.reflectAll.reflectAll" id="apidoc.element.async.reflectAll.reflectAll">
        function <span class="apidocSignatureSpan">async.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function (task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, 'two');
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = 'one'
*     // results[1].error = Error('bad stuff happened')
*     // results[2].value = 'two'
* });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.reject" id="apidoc.module.async.reject">module async.reject</a></h1>


    <h2>
        <a href="#apidoc.element.async.reject.reject" id="apidoc.element.async.reject.reject">
        function <span class="apidocSignatureSpan">async.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.rejectLimit" id="apidoc.module.async.rejectLimit">module async.rejectLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.rejectLimit.rejectLimit" id="apidoc.element.async.rejectLimit.rejectLimit">
        function <span class="apidocSignatureSpan">async.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.rejectSeries" id="apidoc.module.async.rejectSeries">module async.rejectSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.rejectSeries.rejectSeries" id="apidoc.element.async.rejectSeries.rejectSeries">
        function <span class="apidocSignatureSpan">async.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.rest" id="apidoc.module.async.rest">module async.rest</a></h1>


    <h2>
        <a href="#apidoc.element.async.rest.rest" id="apidoc.element.async.rest.rest">
        function <span class="apidocSignatureSpan">async.</span>rest
        <span class="apidocSignatureSpan">(func, start)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rest(func, start) {
    return (0, _overRest3.default)(func, start, _identity2.default);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.retry" id="apidoc.module.async.retry">module async.retry</a></h1>


    <h2>
        <a href="#apidoc.element.async.retry.retry" id="apidoc.element.async.retry.retry">
        function <span class="apidocSignatureSpan">async.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === 'object') {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === 'number' || typeof t === 'string') {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error("Invalid arguments for async.retry");
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === 'function') {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = wrapAsync$1(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp; (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.retryable" id="apidoc.module.async.retryable">module async.retryable</a></h1>


    <h2>
        <a href="#apidoc.element.async.retryable.retryable" id="apidoc.element.async.retryable.retryable">
        function <span class="apidocSignatureSpan">async.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync$1(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);else retry(taskFn, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     // do something with the result
 * });
 *
 * // It can also be embedded within other control flow functions to retry
 * // individual methods that are not as reliable, like this:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
function retry(opts, task, callback) {
var DEFAULT_TIMES = 5;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.seq" id="apidoc.module.async.seq">module async.seq</a></h1>


    <h2>
        <a href="#apidoc.element.async.seq.seq" id="apidoc.element.async.seq.seq">
        function <span class="apidocSignatureSpan">async.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seq = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende's orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get('/cats', function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.series" id="apidoc.module.async.series">module async.series</a></h1>


    <h2>
        <a href="#apidoc.element.async.series.series" id="apidoc.element.async.series.series">
        function <span class="apidocSignatureSpan">async.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  _parallel(eachOfSeries, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, 'one');
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, 'two');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.setImmediate" id="apidoc.module.async.setImmediate">module async.setImmediate</a></h1>


    <h2>
        <a href="#apidoc.element.async.setImmediate.setImmediate" id="apidoc.element.async.setImmediate.setImmediate">
        function <span class="apidocSignatureSpan">async.</span>setImmediate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function () {
  var args = arguments,
      index = -1,
      length = nativeMax(args.length - start, 0),
      array = Array(length);

  while (++index &lt; length) {
    array[index] = args[start + index];
  }
  index = -1;
  var otherArgs = Array(start + 1);
  while (++index &lt; start) {
    otherArgs[index] = args[index];
  }
  otherArgs[start] = transform(array);
  return apply(func, this, otherArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push('two');
 *     // call_order now equals ['one','two']
 * });
 * call_order.push('one');
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.some" id="apidoc.module.async.some">module async.some</a></h1>


    <h2>
        <a href="#apidoc.element.async.some.some" id="apidoc.element.async.some.some">
        function <span class="apidocSignatureSpan">async.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>(['file1','file2','file3'], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.someLimit" id="apidoc.module.async.someLimit">module async.someLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.someLimit.someLimit" id="apidoc.element.async.someLimit.someLimit">
        function <span class="apidocSignatureSpan">async.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync$1(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.someSeries" id="apidoc.module.async.someSeries">module async.someSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.someSeries.someSeries" id="apidoc.element.async.someSeries.someSeries">
        function <span class="apidocSignatureSpan">async.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.sortBy" id="apidoc.module.async.sortBy">module async.sortBy</a></h1>


    <h2>
        <a href="#apidoc.element.async.sortBy.sortBy" id="apidoc.element.async.sortBy.sortBy">
        function <span class="apidocSignatureSpan">async.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = wrapAsync$1(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, { value: x, criteria: criteria });
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
    });

    function comparator(left, right) {
        var a = left.criteria,
            b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>(['file1','file2','file3'], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.timeout" id="apidoc.module.async.timeout">module async.timeout</a></h1>


    <h2>
        <a href="#apidoc.element.async.timeout.timeout" id="apidoc.element.async.timeout.timeout">
        function <span class="apidocSignatureSpan">async.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var originalCallback, timer;
    var timedOut = false;

    function injectedCallback() {
        if (!timedOut) {
            originalCallback.apply(null, arguments);
            clearTimeout(timer);
        }
    }

    function timeoutCallback() {
        var name = asyncFn.name || 'anonymous';
        var error = new Error('Callback function "' + name + '" timed out.');
        error.code = 'ETIMEDOUT';
        if (info) {
            error.info = info;
        }
        timedOut = true;
        originalCallback(error);
    }

    var fn = wrapAsync$1(asyncFn);

    return initialParams(function (args, origCallback) {
        originalCallback = origCallback;
        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args.concat(injectedCallback));
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: 'bar' }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code 'ETIMEDOUT'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.times" id="apidoc.module.async.times">module async.times</a></h1>


    <h2>
        <a href="#apidoc.element.async.times.times" id="apidoc.element.async.times.times">
        function <span class="apidocSignatureSpan">async.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: 'user' + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.timesLimit" id="apidoc.module.async.timesLimit">module async.timesLimit</a></h1>


    <h2>
        <a href="#apidoc.element.async.timesLimit.timesLimit" id="apidoc.element.async.timesLimit.timesLimit">
        function <span class="apidocSignatureSpan">async.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync$1(iteratee);
  mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.timesSeries" id="apidoc.module.async.timesSeries">module async.timesSeries</a></h1>


    <h2>
        <a href="#apidoc.element.async.timesSeries.timesSeries" id="apidoc.element.async.timesSeries.timesSeries">
        function <span class="apidocSignatureSpan">async.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.transform" id="apidoc.module.async.transform">module async.transform</a></h1>


    <h2>
        <a href="#apidoc.element.async.transform.transform" id="apidoc.element.async.transform.transform">
        function <span class="apidocSignatureSpan">async.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);

    eachOf(coll, function (v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function (err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.unmemoize" id="apidoc.module.async.unmemoize">module async.unmemoize</a></h1>


    <h2>
        <a href="#apidoc.element.async.unmemoize.unmemoize" id="apidoc.element.async.unmemoize.unmemoize">
        function <span class="apidocSignatureSpan">async.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.until" id="apidoc.module.async.until">module async.until</a></h1>


    <h2>
        <a href="#apidoc.element.async.until.until" id="apidoc.element.async.until.until">
        function <span class="apidocSignatureSpan">async.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    whilst(function () {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.waterfall" id="apidoc.module.async.waterfall">module async.waterfall</a></h1>


    <h2>
        <a href="#apidoc.element.async.waterfall.waterfall" id="apidoc.element.async.waterfall.waterfall">
        function <span class="apidocSignatureSpan">async.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        if (taskIndex === tasks.length) {
            return callback.apply(null, [null].concat(args));
        }

        var taskCallback = onlyOnce(rest(function (err, args) {
            if (err) {
                return callback.apply(null, [err].concat(args));
            }
            nextTask(args);
        }));

        args.push(taskCallback);

        var task = wrapAsync$1(tasks[taskIndex++]);
        task.apply(null, args);
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous funuction, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, "utf8"),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.whilst" id="apidoc.module.async.whilst">module async.whilst</a></h1>


    <h2>
        <a href="#apidoc.element.async.whilst.whilst" id="apidoc.element.async.whilst.whilst">
        function <span class="apidocSignatureSpan">async.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync$1(iteratee);
    if (!test()) return callback(null);
    var next = rest(function (err, args) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    });
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`'s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.withoutIndex" id="apidoc.module.async.withoutIndex">module async.withoutIndex</a></h1>


    <h2>
        <a href="#apidoc.element.async.withoutIndex.withoutIndex" id="apidoc.element.async.withoutIndex.withoutIndex">
        function <span class="apidocSignatureSpan">async.</span>withoutIndex
        <span class="apidocSignatureSpan">(iteratee)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _withoutIndex(iteratee) {
    return function (value, index, callback) {
        return iteratee(value, callback);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.wrapAsync" id="apidoc.module.async.wrapAsync">module async.wrapAsync</a></h1>


    <h2>
        <a href="#apidoc.element.async.wrapAsync.default" id="apidoc.element.async.wrapAsync.default">
        function <span class="apidocSignatureSpan">async.wrapAsync.</span>default
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function identity(value) {
  return value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        q.process();
    });
}

var isProcessing = false;
var q = {
    _tasks: new _DoublyLinkedList2.<span class="apidocCodeKeywordSpan">default</span>(),
    concurrency: concurrency,
    payload: payload,
    saturated: _noop2.default,
    unsaturated: _noop2.default,
    buffer: concurrency / 4,
    empty: _noop2.default,
    drain: _noop2.default,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.wrapAsync.isAsync" id="apidoc.element.async.wrapAsync.isAsync">
        function <span class="apidocSignatureSpan">async.wrapAsync.</span>isAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAsync(fn) {
    return supportsSymbol &amp;&amp; fn[Symbol.toStringTag] === 'AsyncFunction';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.wrapAsync.supportsAsync" id="apidoc.element.async.wrapAsync.supportsAsync">
        function <span class="apidocSignatureSpan">async.wrapAsync.</span>supportsAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supportsAsync() {
    var supported;
    try {
<span class="apidocCodeCommentSpan">        /* eslint no-eval: 0 */
</span>        supported = isAsync(eval('(async function () {})'));
    } catch (e) {
        supported = false;
    }
    return supported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>