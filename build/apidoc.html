<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    overflow-wrap: break-word;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://caolan.github.io/async/"

    >async (2.6.1)</a>
</h1>
<h4>Higher-order functions and common patterns for asynchronous code</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.async">module async</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList">
            function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.all">
            function <span class="apidocSignatureSpan">async.</span>all
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.allLimit">
            function <span class="apidocSignatureSpan">async.</span>allLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.allSeries">
            function <span class="apidocSignatureSpan">async.</span>allSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.any">
            function <span class="apidocSignatureSpan">async.</span>any
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.anyLimit">
            function <span class="apidocSignatureSpan">async.</span>anyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.anySeries">
            function <span class="apidocSignatureSpan">async.</span>anySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.apply">
            function <span class="apidocSignatureSpan">async.</span>apply
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEach">
            function <span class="apidocSignatureSpan">async.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.applyEachSeries">
            function <span class="apidocSignatureSpan">async.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.asyncify">
            function <span class="apidocSignatureSpan">async.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.auto">
            function <span class="apidocSignatureSpan">async.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.autoInject">
            function <span class="apidocSignatureSpan">async.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.cargo">
            function <span class="apidocSignatureSpan">async.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.compose">
            function <span class="apidocSignatureSpan">async.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concat">
            function <span class="apidocSignatureSpan">async.</span>concat
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concatLimit">
            function <span class="apidocSignatureSpan">async.</span>concatLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.concatSeries">
            function <span class="apidocSignatureSpan">async.</span>concatSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.constant">
            function <span class="apidocSignatureSpan">async.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detect">
            function <span class="apidocSignatureSpan">async.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectLimit">
            function <span class="apidocSignatureSpan">async.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.detectSeries">
            function <span class="apidocSignatureSpan">async.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.dir">
            function <span class="apidocSignatureSpan">async.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doDuring">
            function <span class="apidocSignatureSpan">async.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doUntil">
            function <span class="apidocSignatureSpan">async.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.doWhilst">
            function <span class="apidocSignatureSpan">async.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.during">
            function <span class="apidocSignatureSpan">async.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.each">
            function <span class="apidocSignatureSpan">async.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachLimit">
            function <span class="apidocSignatureSpan">async.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOf">
            function <span class="apidocSignatureSpan">async.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfLimit">
            function <span class="apidocSignatureSpan">async.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachOfSeries">
            function <span class="apidocSignatureSpan">async.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.eachSeries">
            function <span class="apidocSignatureSpan">async.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.ensureAsync">
            function <span class="apidocSignatureSpan">async.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.every">
            function <span class="apidocSignatureSpan">async.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everyLimit">
            function <span class="apidocSignatureSpan">async.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.everySeries">
            function <span class="apidocSignatureSpan">async.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filter">
            function <span class="apidocSignatureSpan">async.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterLimit">
            function <span class="apidocSignatureSpan">async.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.filterSeries">
            function <span class="apidocSignatureSpan">async.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.find">
            function <span class="apidocSignatureSpan">async.</span>find
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findLimit">
            function <span class="apidocSignatureSpan">async.</span>findLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.findSeries">
            function <span class="apidocSignatureSpan">async.</span>findSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.foldl">
            function <span class="apidocSignatureSpan">async.</span>foldl
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.foldr">
            function <span class="apidocSignatureSpan">async.</span>foldr
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEach">
            function <span class="apidocSignatureSpan">async.</span>forEach
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachLimit">
            function <span class="apidocSignatureSpan">async.</span>forEachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOf">
            function <span class="apidocSignatureSpan">async.</span>forEachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOfLimit">
            function <span class="apidocSignatureSpan">async.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachOfSeries">
            function <span class="apidocSignatureSpan">async.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forEachSeries">
            function <span class="apidocSignatureSpan">async.</span>forEachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.forever">
            function <span class="apidocSignatureSpan">async.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBy">
            function <span class="apidocSignatureSpan">async.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupByLimit">
            function <span class="apidocSignatureSpan">async.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.groupBySeries">
            function <span class="apidocSignatureSpan">async.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.inject">
            function <span class="apidocSignatureSpan">async.</span>inject
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.log">
            function <span class="apidocSignatureSpan">async.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.map">
            function <span class="apidocSignatureSpan">async.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapLimit">
            function <span class="apidocSignatureSpan">async.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapSeries">
            function <span class="apidocSignatureSpan">async.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValues">
            function <span class="apidocSignatureSpan">async.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.memoize">
            function <span class="apidocSignatureSpan">async.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.nextTick">
            function <span class="apidocSignatureSpan">async.</span>nextTick
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallel">
            function <span class="apidocSignatureSpan">async.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.parallelLimit">
            function <span class="apidocSignatureSpan">async.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.priorityQueue">
            function <span class="apidocSignatureSpan">async.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.queue">
            function <span class="apidocSignatureSpan">async.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.race">
            function <span class="apidocSignatureSpan">async.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduce">
            function <span class="apidocSignatureSpan">async.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reduceRight">
            function <span class="apidocSignatureSpan">async.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflect">
            function <span class="apidocSignatureSpan">async.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reflectAll">
            function <span class="apidocSignatureSpan">async.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.reject">
            function <span class="apidocSignatureSpan">async.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectLimit">
            function <span class="apidocSignatureSpan">async.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.rejectSeries">
            function <span class="apidocSignatureSpan">async.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retry">
            function <span class="apidocSignatureSpan">async.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.retryable">
            function <span class="apidocSignatureSpan">async.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.select">
            function <span class="apidocSignatureSpan">async.</span>select
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.selectLimit">
            function <span class="apidocSignatureSpan">async.</span>selectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.selectSeries">
            function <span class="apidocSignatureSpan">async.</span>selectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.seq">
            function <span class="apidocSignatureSpan">async.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.series">
            function <span class="apidocSignatureSpan">async.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.setImmediate">
            function <span class="apidocSignatureSpan">async.</span>setImmediate
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.some">
            function <span class="apidocSignatureSpan">async.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someLimit">
            function <span class="apidocSignatureSpan">async.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.someSeries">
            function <span class="apidocSignatureSpan">async.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.sortBy">
            function <span class="apidocSignatureSpan">async.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timeout">
            function <span class="apidocSignatureSpan">async.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.times">
            function <span class="apidocSignatureSpan">async.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesLimit">
            function <span class="apidocSignatureSpan">async.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.timesSeries">
            function <span class="apidocSignatureSpan">async.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.transform">
            function <span class="apidocSignatureSpan">async.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.tryEach">
            function <span class="apidocSignatureSpan">async.</span>tryEach
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.unmemoize">
            function <span class="apidocSignatureSpan">async.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.until">
            function <span class="apidocSignatureSpan">async.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.waterfall">
            function <span class="apidocSignatureSpan">async.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.whilst">
            function <span class="apidocSignatureSpan">async.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapSync">
            function <span class="apidocSignatureSpan">async.</span>wrapSync
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>DoublyLinkedList.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>default</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.</span>wrapAsync</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.DoublyLinkedList">module async.DoublyLinkedList</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.DoublyLinkedList">
            function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.DoublyLinkedList.prototype">module async.DoublyLinkedList.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.empty">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.insertAfter">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(node, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.insertBefore">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(node, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.pop">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.push">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.remove">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>remove
            <span class="apidocSignatureSpan">(testFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.removeLink">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>removeLink
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.shift">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.toArray">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.DoublyLinkedList.prototype.unshift">
            function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.default">module async.default</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.all">
            function <span class="apidocSignatureSpan">async.default.</span>all
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.allLimit">
            function <span class="apidocSignatureSpan">async.default.</span>allLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.allSeries">
            function <span class="apidocSignatureSpan">async.default.</span>allSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.any">
            function <span class="apidocSignatureSpan">async.default.</span>any
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.anyLimit">
            function <span class="apidocSignatureSpan">async.default.</span>anyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.anySeries">
            function <span class="apidocSignatureSpan">async.default.</span>anySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.apply">
            function <span class="apidocSignatureSpan">async.default.</span>apply
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.applyEach">
            function <span class="apidocSignatureSpan">async.default.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.applyEachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.asyncify">
            function <span class="apidocSignatureSpan">async.default.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.auto">
            function <span class="apidocSignatureSpan">async.default.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.autoInject">
            function <span class="apidocSignatureSpan">async.default.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.cargo">
            function <span class="apidocSignatureSpan">async.default.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.compose">
            function <span class="apidocSignatureSpan">async.default.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.concat">
            function <span class="apidocSignatureSpan">async.default.</span>concat
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.concatLimit">
            function <span class="apidocSignatureSpan">async.default.</span>concatLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.concatSeries">
            function <span class="apidocSignatureSpan">async.default.</span>concatSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.constant">
            function <span class="apidocSignatureSpan">async.default.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detect">
            function <span class="apidocSignatureSpan">async.default.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.detectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.dir">
            function <span class="apidocSignatureSpan">async.default.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doDuring">
            function <span class="apidocSignatureSpan">async.default.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doUntil">
            function <span class="apidocSignatureSpan">async.default.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.doWhilst">
            function <span class="apidocSignatureSpan">async.default.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.during">
            function <span class="apidocSignatureSpan">async.default.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.each">
            function <span class="apidocSignatureSpan">async.default.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachLimit">
            function <span class="apidocSignatureSpan">async.default.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOf">
            function <span class="apidocSignatureSpan">async.default.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOfLimit">
            function <span class="apidocSignatureSpan">async.default.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachOfSeries">
            function <span class="apidocSignatureSpan">async.default.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.eachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.ensureAsync">
            function <span class="apidocSignatureSpan">async.default.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.every">
            function <span class="apidocSignatureSpan">async.default.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.everyLimit">
            function <span class="apidocSignatureSpan">async.default.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.everySeries">
            function <span class="apidocSignatureSpan">async.default.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filter">
            function <span class="apidocSignatureSpan">async.default.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filterLimit">
            function <span class="apidocSignatureSpan">async.default.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.filterSeries">
            function <span class="apidocSignatureSpan">async.default.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.find">
            function <span class="apidocSignatureSpan">async.default.</span>find
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.findLimit">
            function <span class="apidocSignatureSpan">async.default.</span>findLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.findSeries">
            function <span class="apidocSignatureSpan">async.default.</span>findSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.foldl">
            function <span class="apidocSignatureSpan">async.default.</span>foldl
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.foldr">
            function <span class="apidocSignatureSpan">async.default.</span>foldr
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEach">
            function <span class="apidocSignatureSpan">async.default.</span>forEach
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachLimit">
            function <span class="apidocSignatureSpan">async.default.</span>forEachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOf">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOfLimit">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachOfSeries">
            function <span class="apidocSignatureSpan">async.default.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forEachSeries">
            function <span class="apidocSignatureSpan">async.default.</span>forEachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.forever">
            function <span class="apidocSignatureSpan">async.default.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupBy">
            function <span class="apidocSignatureSpan">async.default.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupByLimit">
            function <span class="apidocSignatureSpan">async.default.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.groupBySeries">
            function <span class="apidocSignatureSpan">async.default.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.inject">
            function <span class="apidocSignatureSpan">async.default.</span>inject
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.log">
            function <span class="apidocSignatureSpan">async.default.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.map">
            function <span class="apidocSignatureSpan">async.default.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapLimit">
            function <span class="apidocSignatureSpan">async.default.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapSeries">
            function <span class="apidocSignatureSpan">async.default.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValues">
            function <span class="apidocSignatureSpan">async.default.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.default.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.default.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.memoize">
            function <span class="apidocSignatureSpan">async.default.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.nextTick">
            function <span class="apidocSignatureSpan">async.default.</span>nextTick
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.parallel">
            function <span class="apidocSignatureSpan">async.default.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.parallelLimit">
            function <span class="apidocSignatureSpan">async.default.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.priorityQueue">
            function <span class="apidocSignatureSpan">async.default.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.queue">
            function <span class="apidocSignatureSpan">async.default.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.race">
            function <span class="apidocSignatureSpan">async.default.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reduce">
            function <span class="apidocSignatureSpan">async.default.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reduceRight">
            function <span class="apidocSignatureSpan">async.default.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reflect">
            function <span class="apidocSignatureSpan">async.default.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reflectAll">
            function <span class="apidocSignatureSpan">async.default.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.reject">
            function <span class="apidocSignatureSpan">async.default.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.rejectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.rejectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.retry">
            function <span class="apidocSignatureSpan">async.default.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.retryable">
            function <span class="apidocSignatureSpan">async.default.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.select">
            function <span class="apidocSignatureSpan">async.default.</span>select
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.selectLimit">
            function <span class="apidocSignatureSpan">async.default.</span>selectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.selectSeries">
            function <span class="apidocSignatureSpan">async.default.</span>selectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.seq">
            function <span class="apidocSignatureSpan">async.default.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.series">
            function <span class="apidocSignatureSpan">async.default.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.setImmediate">
            function <span class="apidocSignatureSpan">async.default.</span>setImmediate
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.some">
            function <span class="apidocSignatureSpan">async.default.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.someLimit">
            function <span class="apidocSignatureSpan">async.default.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.someSeries">
            function <span class="apidocSignatureSpan">async.default.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.sortBy">
            function <span class="apidocSignatureSpan">async.default.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timeout">
            function <span class="apidocSignatureSpan">async.default.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.times">
            function <span class="apidocSignatureSpan">async.default.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timesLimit">
            function <span class="apidocSignatureSpan">async.default.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.timesSeries">
            function <span class="apidocSignatureSpan">async.default.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.transform">
            function <span class="apidocSignatureSpan">async.default.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.tryEach">
            function <span class="apidocSignatureSpan">async.default.</span>tryEach
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.unmemoize">
            function <span class="apidocSignatureSpan">async.default.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.until">
            function <span class="apidocSignatureSpan">async.default.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.waterfall">
            function <span class="apidocSignatureSpan">async.default.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.whilst">
            function <span class="apidocSignatureSpan">async.default.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.default.wrapSync">
            function <span class="apidocSignatureSpan">async.default.</span>wrapSync
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.index">module async.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.all">
            function <span class="apidocSignatureSpan">async.index.</span>all
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.allLimit">
            function <span class="apidocSignatureSpan">async.index.</span>allLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.allSeries">
            function <span class="apidocSignatureSpan">async.index.</span>allSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.any">
            function <span class="apidocSignatureSpan">async.index.</span>any
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.anyLimit">
            function <span class="apidocSignatureSpan">async.index.</span>anyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.anySeries">
            function <span class="apidocSignatureSpan">async.index.</span>anySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.apply">
            function <span class="apidocSignatureSpan">async.index.</span>apply
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.applyEach">
            function <span class="apidocSignatureSpan">async.index.</span>applyEach
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.applyEachSeries">
            function <span class="apidocSignatureSpan">async.index.</span>applyEachSeries
            <span class="apidocSignatureSpan">(fns)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.asyncify">
            function <span class="apidocSignatureSpan">async.index.</span>asyncify
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.auto">
            function <span class="apidocSignatureSpan">async.index.</span>auto
            <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.autoInject">
            function <span class="apidocSignatureSpan">async.index.</span>autoInject
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.cargo">
            function <span class="apidocSignatureSpan">async.index.</span>cargo
            <span class="apidocSignatureSpan">(worker, payload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.compose">
            function <span class="apidocSignatureSpan">async.index.</span>compose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.concat">
            function <span class="apidocSignatureSpan">async.index.</span>concat
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.concatLimit">
            function <span class="apidocSignatureSpan">async.index.</span>concatLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.concatSeries">
            function <span class="apidocSignatureSpan">async.index.</span>concatSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.constant">
            function <span class="apidocSignatureSpan">async.index.</span>constant
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.detect">
            function <span class="apidocSignatureSpan">async.index.</span>detect
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.detectLimit">
            function <span class="apidocSignatureSpan">async.index.</span>detectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.detectSeries">
            function <span class="apidocSignatureSpan">async.index.</span>detectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.dir">
            function <span class="apidocSignatureSpan">async.index.</span>dir
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.doDuring">
            function <span class="apidocSignatureSpan">async.index.</span>doDuring
            <span class="apidocSignatureSpan">(fn, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.doUntil">
            function <span class="apidocSignatureSpan">async.index.</span>doUntil
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.doWhilst">
            function <span class="apidocSignatureSpan">async.index.</span>doWhilst
            <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.during">
            function <span class="apidocSignatureSpan">async.index.</span>during
            <span class="apidocSignatureSpan">(test, fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.each">
            function <span class="apidocSignatureSpan">async.index.</span>each
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.eachLimit">
            function <span class="apidocSignatureSpan">async.index.</span>eachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.eachOf">
            function <span class="apidocSignatureSpan">async.index.</span>eachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.eachOfLimit">
            function <span class="apidocSignatureSpan">async.index.</span>eachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.eachOfSeries">
            function <span class="apidocSignatureSpan">async.index.</span>eachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.eachSeries">
            function <span class="apidocSignatureSpan">async.index.</span>eachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.ensureAsync">
            function <span class="apidocSignatureSpan">async.index.</span>ensureAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.every">
            function <span class="apidocSignatureSpan">async.index.</span>every
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.everyLimit">
            function <span class="apidocSignatureSpan">async.index.</span>everyLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.everySeries">
            function <span class="apidocSignatureSpan">async.index.</span>everySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.filter">
            function <span class="apidocSignatureSpan">async.index.</span>filter
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.filterLimit">
            function <span class="apidocSignatureSpan">async.index.</span>filterLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.filterSeries">
            function <span class="apidocSignatureSpan">async.index.</span>filterSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.find">
            function <span class="apidocSignatureSpan">async.index.</span>find
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.findLimit">
            function <span class="apidocSignatureSpan">async.index.</span>findLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.findSeries">
            function <span class="apidocSignatureSpan">async.index.</span>findSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.foldl">
            function <span class="apidocSignatureSpan">async.index.</span>foldl
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.foldr">
            function <span class="apidocSignatureSpan">async.index.</span>foldr
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEach">
            function <span class="apidocSignatureSpan">async.index.</span>forEach
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEachLimit">
            function <span class="apidocSignatureSpan">async.index.</span>forEachLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEachOf">
            function <span class="apidocSignatureSpan">async.index.</span>forEachOf
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEachOfLimit">
            function <span class="apidocSignatureSpan">async.index.</span>forEachOfLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEachOfSeries">
            function <span class="apidocSignatureSpan">async.index.</span>forEachOfSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forEachSeries">
            function <span class="apidocSignatureSpan">async.index.</span>forEachSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.forever">
            function <span class="apidocSignatureSpan">async.index.</span>forever
            <span class="apidocSignatureSpan">(fn, errback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.groupBy">
            function <span class="apidocSignatureSpan">async.index.</span>groupBy
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.groupByLimit">
            function <span class="apidocSignatureSpan">async.index.</span>groupByLimit
            <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.groupBySeries">
            function <span class="apidocSignatureSpan">async.index.</span>groupBySeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.inject">
            function <span class="apidocSignatureSpan">async.index.</span>inject
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.log">
            function <span class="apidocSignatureSpan">async.index.</span>log
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.map">
            function <span class="apidocSignatureSpan">async.index.</span>map
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.mapLimit">
            function <span class="apidocSignatureSpan">async.index.</span>mapLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.mapSeries">
            function <span class="apidocSignatureSpan">async.index.</span>mapSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.mapValues">
            function <span class="apidocSignatureSpan">async.index.</span>mapValues
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.mapValuesLimit">
            function <span class="apidocSignatureSpan">async.index.</span>mapValuesLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.mapValuesSeries">
            function <span class="apidocSignatureSpan">async.index.</span>mapValuesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.memoize">
            function <span class="apidocSignatureSpan">async.index.</span>memoize
            <span class="apidocSignatureSpan">(fn, hasher)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.nextTick">
            function <span class="apidocSignatureSpan">async.index.</span>nextTick
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.parallel">
            function <span class="apidocSignatureSpan">async.index.</span>parallel
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.parallelLimit">
            function <span class="apidocSignatureSpan">async.index.</span>parallelLimit
            <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.priorityQueue">
            function <span class="apidocSignatureSpan">async.index.</span>priorityQueue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.queue">
            function <span class="apidocSignatureSpan">async.index.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.race">
            function <span class="apidocSignatureSpan">async.index.</span>race
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.reduce">
            function <span class="apidocSignatureSpan">async.index.</span>reduce
            <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.reduceRight">
            function <span class="apidocSignatureSpan">async.index.</span>reduceRight
            <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.reflect">
            function <span class="apidocSignatureSpan">async.index.</span>reflect
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.reflectAll">
            function <span class="apidocSignatureSpan">async.index.</span>reflectAll
            <span class="apidocSignatureSpan">(tasks)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.reject">
            function <span class="apidocSignatureSpan">async.index.</span>reject
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.rejectLimit">
            function <span class="apidocSignatureSpan">async.index.</span>rejectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.rejectSeries">
            function <span class="apidocSignatureSpan">async.index.</span>rejectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.retry">
            function <span class="apidocSignatureSpan">async.index.</span>retry
            <span class="apidocSignatureSpan">(opts, task, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.retryable">
            function <span class="apidocSignatureSpan">async.index.</span>retryable
            <span class="apidocSignatureSpan">(opts, task)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.select">
            function <span class="apidocSignatureSpan">async.index.</span>select
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.selectLimit">
            function <span class="apidocSignatureSpan">async.index.</span>selectLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.selectSeries">
            function <span class="apidocSignatureSpan">async.index.</span>selectSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.seq">
            function <span class="apidocSignatureSpan">async.index.</span>seq
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.series">
            function <span class="apidocSignatureSpan">async.index.</span>series
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.setImmediate">
            function <span class="apidocSignatureSpan">async.index.</span>setImmediate
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.some">
            function <span class="apidocSignatureSpan">async.index.</span>some
            <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.someLimit">
            function <span class="apidocSignatureSpan">async.index.</span>someLimit
            <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.someSeries">
            function <span class="apidocSignatureSpan">async.index.</span>someSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.sortBy">
            function <span class="apidocSignatureSpan">async.index.</span>sortBy
            <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.timeout">
            function <span class="apidocSignatureSpan">async.index.</span>timeout
            <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.times">
            function <span class="apidocSignatureSpan">async.index.</span>times
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.timesLimit">
            function <span class="apidocSignatureSpan">async.index.</span>timesLimit
            <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.timesSeries">
            function <span class="apidocSignatureSpan">async.index.</span>timesSeries
            <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.transform">
            function <span class="apidocSignatureSpan">async.index.</span>transform
            <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.tryEach">
            function <span class="apidocSignatureSpan">async.index.</span>tryEach
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.unmemoize">
            function <span class="apidocSignatureSpan">async.index.</span>unmemoize
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.until">
            function <span class="apidocSignatureSpan">async.index.</span>until
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.waterfall">
            function <span class="apidocSignatureSpan">async.index.</span>waterfall
            <span class="apidocSignatureSpan">(tasks, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.whilst">
            function <span class="apidocSignatureSpan">async.index.</span>whilst
            <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.index.wrapSync">
            function <span class="apidocSignatureSpan">async.index.</span>wrapSync
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">async.index.</span>default</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.async.wrapAsync">module async.wrapAsync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapAsync.default">
            function <span class="apidocSignatureSpan">async.wrapAsync.</span>default
            <span class="apidocSignatureSpan">(asyncFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.async.wrapAsync.isAsync">
            function <span class="apidocSignatureSpan">async.wrapAsync.</span>isAsync
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async" id="apidoc.module.async">module async</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList" id="apidoc.element.async.DoublyLinkedList">
        function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.all" id="apidoc.element.async.all">
        function <span class="apidocSignatureSpan">async.</span>all
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.allLimit" id="apidoc.element.async.allLimit">
        function <span class="apidocSignatureSpan">async.</span>allLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.allSeries" id="apidoc.element.async.allSeries">
        function <span class="apidocSignatureSpan">async.</span>allSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.any" id="apidoc.element.async.any">
        function <span class="apidocSignatureSpan">async.</span>any
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.anyLimit" id="apidoc.element.async.anyLimit">
        function <span class="apidocSignatureSpan">async.</span>anyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.anySeries" id="apidoc.element.async.anySeries">
        function <span class="apidocSignatureSpan">async.</span>anySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.apply" id="apidoc.element.async.apply">
        function <span class="apidocSignatureSpan">async.</span>apply
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (fn) {
    var args = slice(arguments, 1);
    return function(/*callArgs*/) {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args.concat(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.applyEach" id="apidoc.element.async.applyEach">
        function <span class="apidocSignatureSpan">async.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function (fns) {
    var args = slice(arguments, 1);
    var go = initialParams(function(args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            wrapAsync(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    }
    else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], &apos;bucket&apos;, callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.applyEachSeries" id="apidoc.element.async.applyEachSeries">
        function <span class="apidocSignatureSpan">async.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function (fns) {
    var args = slice(arguments, 1);
    var go = initialParams(function(args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            wrapAsync(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    }
    else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.asyncify" id="apidoc.element.async.asyncify">
        function <span class="apidocSignatureSpan">async.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.auto" id="apidoc.element.async.auto">
        function <span class="apidocSignatureSpan">async.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === &apos;function&apos;) {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error(&apos;async.auto task `&apos; + key +
                    &apos;` has a non-existent dependency `&apos; +
                    dependencyName + &apos;` in &apos; +
                    dependencies.join(&apos;, &apos;));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length &gt; 2) {
                result = slice(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn&apos;s algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, &apos;data.txt&apos;, &apos;utf-8&apos;),
*     showData: [&apos;readData&apos;, function(results, cb) {
*         // results.readData is the file&apos;s contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.autoInject" id="apidoc.element.async.autoInject">
        function <span class="apidocSignatureSpan">async.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync &amp;&amp; taskFn.length === 1) ||
            (fnIsAsync &amp;&amp; taskFn.length === 0);

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error(&quot;autoInject task functions require explicit parameters.&quot;);
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, &apos;data&apos;, &apos;converted to array&apos;);
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.cargo" id="apidoc.element.async.cargo">
        function <span class="apidocSignatureSpan">async.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
    return queue(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log(&apos;hello &apos; + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.compose" id="apidoc.element.async.compose">
        function <span class="apidocSignatureSpan">async.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () {
    return seq.apply(null, slice(arguments).reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.concat" id="apidoc.element.async.concat">
        function <span class="apidocSignatureSpan">async.</span>concat
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.concatLimit" id="apidoc.element.async.concatLimit">
        function <span class="apidocSignatureSpan">async.</span>concatLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, slice(arguments, 1));
        });
    }, function(err, mapResults) {
        var result = [];
        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.concatSeries" id="apidoc.element.async.concatSeries">
        function <span class="apidocSignatureSpan">async.</span>concatSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.constant" id="apidoc.element.async.constant">
        function <span class="apidocSignatureSpan">async.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () {
    var values = slice(arguments);
    var args = [null].concat(values);
    return function (/*...ignoredArgs, callback*/) {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detect" id="apidoc.element.async.detect">
        function <span class="apidocSignatureSpan">async.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detectLimit" id="apidoc.element.async.detectLimit">
        function <span class="apidocSignatureSpan">async.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.detectSeries" id="apidoc.element.async.detectSeries">
        function <span class="apidocSignatureSpan">async.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.dir" id="apidoc.element.async.dir">
        function <span class="apidocSignatureSpan">async.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
    var args = slice(arguments, 1);
    args.push(function (err/*, ...args*/) {
        var args = slice(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                arrayEach(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    wrapAsync(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, &apos;world&apos;);
 * {hello: &apos;world&apos;}
 */
exports.default = (0, _consoleFunc2.default)(&apos;dir&apos;);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doDuring" id="apidoc.element.async.doDuring">
        function <span class="apidocSignatureSpan">async.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doUntil" id="apidoc.element.async.doUntil">
        function <span class="apidocSignatureSpan">async.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.doWhilst" id="apidoc.element.async.doWhilst">
        function <span class="apidocSignatureSpan">async.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.during" id="apidoc.element.async.during">
        function <span class="apidocSignatureSpan">async.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.each" id="apidoc.element.async.each">
        function <span class="apidocSignatureSpan">async.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], &apos;bucket&apos;, callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachLimit" id="apidoc.element.async.eachLimit">
        function <span class="apidocSignatureSpan">async.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOf" id="apidoc.element.async.eachOf">
        function <span class="apidocSignatureSpan">async.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOfLimit" id="apidoc.element.async.eachOfLimit">
        function <span class="apidocSignatureSpan">async.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachOfSeries" id="apidoc.element.async.eachOfSeries">
        function <span class="apidocSignatureSpan">async.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.eachSeries" id="apidoc.element.async.eachSeries">
        function <span class="apidocSignatureSpan">async.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.ensureAsync" id="apidoc.element.async.ensureAsync">
        function <span class="apidocSignatureSpan">async.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
3. The callback can accept any number of arguments
4. The first argument passed to the callback will be treated as an error result, if the argument is truthy
5. Any number of result arguments can be passed after the &quot;error&quot; argument
6. The callback is called once and exactly once, either on the same tick or later tick of the JavaScript event loop.

There were several cases where Async accepted some functions that did not strictly have these properties, most notably `auto`, `
every`, `some`, `filter`, `reject` and `detect`.

Another theme is performance. We have eliminated internal deferrals in all cases where they make sense. For example, in `waterfall
` and `auto`, there was a `setImmediate` between each task -- these deferrals have been removed. A `setImmediate` call can add up
 to 1ms of delay. This might not seem like a lot, but it can add up if you are using many Async functions in the course of processing
 a HTTP request, for example. Nearly all asynchronous functions that do I/O already have some sort of deferral built in, so the
extra deferral is unnecessary. The trade-off of this change is removing our built-in stack-overflow defense. Many synchronous callback
 calls in series can quickly overflow the JS call stack. If you do have a function that is sometimes synchronous (calling its callback
 on the same tick), and are running into stack overflows, wrap it with `async.<span class="apidocCodeKeywordSpan">ensureAsync</span
>()`.

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.every" id="apidoc.element.async.every">
        function <span class="apidocSignatureSpan">async.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.everyLimit" id="apidoc.element.async.everyLimit">
        function <span class="apidocSignatureSpan">async.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.everySeries" id="apidoc.element.async.everySeries">
        function <span class="apidocSignatureSpan">async.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filter" id="apidoc.element.async.filter">
        function <span class="apidocSignatureSpan">async.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filterLimit" id="apidoc.element.async.filterLimit">
        function <span class="apidocSignatureSpan">async.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.filterSeries" id="apidoc.element.async.filterSeries">
        function <span class="apidocSignatureSpan">async.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.find" id="apidoc.element.async.find">
        function <span class="apidocSignatureSpan">async.</span>find
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.findLimit" id="apidoc.element.async.findLimit">
        function <span class="apidocSignatureSpan">async.</span>findLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.findSeries" id="apidoc.element.async.findSeries">
        function <span class="apidocSignatureSpan">async.</span>findSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.foldl" id="apidoc.element.async.foldl">
        function <span class="apidocSignatureSpan">async.</span>foldl
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.foldr" id="apidoc.element.async.foldr">
        function <span class="apidocSignatureSpan">async.</span>foldr
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEach" id="apidoc.element.async.forEach">
        function <span class="apidocSignatureSpan">async.</span>forEach
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachLimit" id="apidoc.element.async.forEachLimit">
        function <span class="apidocSignatureSpan">async.</span>forEachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOf" id="apidoc.element.async.forEachOf">
        function <span class="apidocSignatureSpan">async.</span>forEachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called when all
* `iteratee` functions have finished, or an error occurs. Invoked with (err).
* @example
*
* var obj = {dev: &quot;/dev.json&quot;, test: &quot;/test.json&quot;, prod: &quot;/prod.json&quot;};
* var configs = {};
*
* async.<span class="apidocCodeKeywordSpan">forEachOf</span>(obj, function (value, key, callback) {
*     fs.readFile(__dirname + value, &quot;utf8&quot;, function (err, data) {
*         if (err) return callback(err);
*         try {
*             configs[key] = JSON.parse(data);
*         } catch (e) {
*             return callback(e);
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOfLimit" id="apidoc.element.async.forEachOfLimit">
        function <span class="apidocSignatureSpan">async.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachOfSeries" id="apidoc.element.async.forEachOfSeries">
        function <span class="apidocSignatureSpan">async.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forEachSeries" id="apidoc.element.async.forEachSeries">
        function <span class="apidocSignatureSpan">async.</span>forEachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.forever" id="apidoc.element.async.forever">
        function <span class="apidocSignatureSpan">async.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it&apos;s callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as &apos;err&apos;, and execution will stop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupBy" id="apidoc.element.async.groupBy">
        function <span class="apidocSignatureSpan">async.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>([&apos;userId1&apos;, &apos;userId2&apos;, &apos;userId3&apos;], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: [&apos;userId1&apos;, &apos;userId3&apos;], 42: [&apos;userId2&apos;]};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupByLimit" id="apidoc.element.async.groupByLimit">
        function <span class="apidocSignatureSpan">async.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err, key) {
            if (err) return callback(err);
            return callback(null, {key: key, val: val});
        });
    }, function(err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.groupBySeries" id="apidoc.element.async.groupBySeries">
        function <span class="apidocSignatureSpan">async.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.inject" id="apidoc.element.async.inject">
        function <span class="apidocSignatureSpan">async.</span>inject
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.log" id="apidoc.element.async.log">
        function <span class="apidocSignatureSpan">async.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
    var args = slice(arguments, 1);
    args.push(function (err/*, ...args*/) {
        var args = slice(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                arrayEach(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    wrapAsync(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     },
*     email_link: function(write_file, callback) {
*         // once the file is written let&apos;s email a link to it...
*         // write_file contains the filename returned by write_file.
*         callback(null, {&apos;file&apos;:write_file, &apos;email&apos;:&apos;user@example.com&apos;});
*     }
* }, function(err, results) {
*     console.<span class="apidocCodeKeywordSpan">log</span>(&apos;err = &apos;, err);
*     console.log(&apos;email_link = &apos;, results.email_link);
* });
*
* // If you are using a JS minifier that mangles parameter names, `autoInject`
* // will not work with plain functions, since the parameter names will be
* // collapsed to a single letter identifier.  To work around this, you can
* // explicitly specify the names of the parameters your task function needs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.map" id="apidoc.element.async.map">
        function <span class="apidocSignatureSpan">async.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, &apos;&apos;);
   func = func.match(FN_ARGS)[2].replace(&apos; &apos;, &apos;&apos;);
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, &apos;&apos;));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapLimit" id="apidoc.element.async.mapLimit">
        function <span class="apidocSignatureSpan">async.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

```javascript
var async = require(&quot;async&quot;);

// ...or ES2017 async functions
async.<span class="apidocCodeKeywordSpan">mapLimit</span>(urls, 5, async function(url) {
    const response = await fetch(url)
    return response.body
}, (err, results) =&gt; {
    if (err) throw err
    // results is now an array of the response bodies
    console.log(results)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapSeries" id="apidoc.element.async.mapSeries">
        function <span class="apidocSignatureSpan">async.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync&apos;s callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValues" id="apidoc.element.async.mapValues">
        function <span class="apidocSignatureSpan">async.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: &apos;file1&apos;,
*     f2: &apos;file2&apos;,
*     f3: &apos;file3&apos;
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValuesLimit" id="apidoc.element.async.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.mapValuesSeries" id="apidoc.element.async.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.memoize" id="apidoc.element.async.memoize">
        function <span class="apidocSignatureSpan">async.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function() {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function(/*args*/) {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn(&apos;some name&apos;, function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.nextTick" id="apidoc.element.async.nextTick">
        function <span class="apidocSignatureSpan">async.</span>nextTick
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function (fn) {
    var args = slice(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.parallel" id="apidoc.element.async.parallel">
        function <span class="apidocSignatureSpan">async.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
    _parallel(eachOf, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @returns {Function} the partially-applied function
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, &apos;testfile1&apos;, &apos;test1&apos;),
*     async.apply(fs.writeFile, &apos;testfile2&apos;, &apos;test2&apos;)
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.parallelLimit" id="apidoc.element.async.parallelLimit">
        function <span class="apidocSignatureSpan">async.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit$1(tasks, limit, callback) {
    _parallel(_eachOfLimit(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.priorityQueue" id="apidoc.element.async.priorityQueue">
        function <span class="apidocSignatureSpan">async.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function(data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== &apos;function&apos;) {
            throw new Error(&apos;task callback must be a function&apos;);
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.queue" id="apidoc.element.async.queue">
        function <span class="apidocSignatureSpan">async.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue(function (items, cb) {
        _worker(items[0], cb);
    }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.race" id="apidoc.element.async.race">
        function <span class="apidocSignatureSpan">async.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError(&apos;First argument to race must be an array of functions&apos;));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`. It will run an array of async tasks in
 parallel and will call its callback with the result of the first task to respond. ([#568](https://github.com/caolan/async/issues
/568), [#1038](https://github.com/caolan/async/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.reflect()`](http://bluebirdjs.com/docs/api/reflect.html), a wrapper for
 async tasks that always succeeds, by gathering results and errors into an object.  ([#942](https://github.com/caolan/async/issues
/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reduce" id="apidoc.element.async.reduce">
        function <span class="apidocSignatureSpan">async.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reduceRight" id="apidoc.element.async.reduceRight">
        function <span class="apidocSignatureSpan">async.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reflect" id="apidoc.element.async.reflect">
        function <span class="apidocSignatureSpan">async.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length &lt;= 2) {
                    value = cbArg;
                } else {
                    value = slice(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.race()`. It will run an array of async tasks in parallel and will call its callback with the
 result of the first task to respond. ([#568](https://github.com/caolan/async/issues/568), [#1038](https://github.com/caolan/async
/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.<span class="apidocCodeKeywordSpan">reflect</span>()`](http://bluebirdjs
.com/docs/api/reflect.html), a wrapper for async tasks that always succeeds, by gathering results and errors into an object.  ([#
942](https://github.com/caolan/async/issues/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com
/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
- Added `autoInject`, a relative of `auto` that automatically spreads a task&apos;s dependencies as arguments to the task function
. ([#608](https://github.com/caolan/async/issues/608), [#1055](https://github.com/caolan/async/issues/1055), [#1099](https://github
.com/caolan/async/issues/1099), [#1100](https://github.com/caolan/async/issues/1100))
- You can now limit the concurrency of `auto` tasks. ([#635](https://github.com/caolan/async/issues/635), [#637](https://github.
com/caolan/async/issues/637))
- Added `retryable`, a relative of `retry` that wraps an async function, making it retry when called. ([#1058](https://github.com
/caolan/async/issues/1058))
- `retry` now supports specifying a function that determines the next time interval, useful for exponential backoff, logging and
 other retry strategies. ([#1161](https://github.com/caolan/async/issues/1161))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reflectAll" id="apidoc.element.async.reflectAll">
        function <span class="apidocSignatureSpan">async.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, &apos;two&apos;);
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = &apos;one&apos;
*     // results[1].error = Error(&apos;bad stuff happened&apos;)
*     // results[2].value = &apos;two&apos;
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.reject" id="apidoc.element.async.reject">
        function <span class="apidocSignatureSpan">async.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `coll`.
* The should complete with a boolean value as its `result`.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reject</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of missing files
*     createFiles(results);
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.rejectLimit" id="apidoc.element.async.rejectLimit">
        function <span class="apidocSignatureSpan">async.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.rejectSeries" id="apidoc.element.async.rejectSeries">
        function <span class="apidocSignatureSpan">async.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.retry" id="apidoc.element.async.retry">
        function <span class="apidocSignatureSpan">async.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === &apos;object&apos;) {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === &apos;function&apos; ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === &apos;number&apos; || typeof t === &apos;string&apos;) {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error(&quot;Invalid arguments for async.retry&quot;);
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === &apos;function&apos;) {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== &apos;function&apos;) {
        throw new Error(&quot;Invalid arguments for async.retry&quot;);
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function(err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp;
                (typeof options.errorFilter != &apos;function&apos; ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.retryable" id="apidoc.element.async.retryable">
        function <span class="apidocSignatureSpan">async.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (...args, callback).
* @returns {AsyncFunction} The wrapped function, which when invoked, will
* retry on an error, based on the parameters specified in `opts`.
* This function will accept the same parameters as `task`.
* @example
*
* async.auto({
*     dep1: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, getFromFlakyService),
*     process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {
*         maybeProcessData(results.dep1, cb);
*     })]
* }, callback);
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.select" id="apidoc.element.async.select">
        function <span class="apidocSignatureSpan">async.</span>select
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.selectLimit" id="apidoc.element.async.selectLimit">
        function <span class="apidocSignatureSpan">async.</span>selectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.selectSeries" id="apidoc.element.async.selectSeries">
        function <span class="apidocSignatureSpan">async.</span>selectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.seq" id="apidoc.element.async.seq">
        function <span class="apidocSignatureSpan">async.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() {
    var _functions = arrayMap(arguments, wrapAsync);
    return function(/*...args*/) {
        var args = slice(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == &apos;function&apos;) {
            args.pop();
        } else {
            cb = noop;
        }

        reduce(_functions, args, function(newargs, fn, cb) {
            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
                var nextargs = slice(arguments, 1);
                cb(err, nextargs);
            }));
        },
        function(err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende&apos;s orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get(&apos;/cats&apos;, function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // &apos;User.get&apos; has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // &apos;getCats&apos; has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.series" id="apidoc.element.async.series">
        function <span class="apidocSignatureSpan">async.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
    _parallel(eachOfSeries, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, &apos;one&apos;);
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, &apos;two&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.setImmediate" id="apidoc.element.async.setImmediate">
        function <span class="apidocSignatureSpan">async.</span>setImmediate
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (fn) {
    var args = slice(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push(&apos;two&apos;);
 *     // call_order now equals [&apos;one&apos;,&apos;two&apos;]
 * });
 * call_order.push(&apos;one&apos;);
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.some" id="apidoc.element.async.some">
        function <span class="apidocSignatureSpan">async.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.someLimit" id="apidoc.element.async.someLimit">
        function <span class="apidocSignatureSpan">async.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.someSeries" id="apidoc.element.async.someSeries">
        function <span class="apidocSignatureSpan">async.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.sortBy" id="apidoc.element.async.sortBy">
        function <span class="apidocSignatureSpan">async.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, {value: x, criteria: criteria});
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty(&apos;value&apos;)));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timeout" id="apidoc.element.async.timeout">
        function <span class="apidocSignatureSpan">async.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || &apos;anonymous&apos;;
            var error  = new Error(&apos;Callback function &quot;&apos; + name + &apos;&quot; timed out.&apos;);
            error.code = &apos;ETIMEDOUT&apos;;
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: &apos;bar&apos; }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code &apos;ETIMEDOUT&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.times" id="apidoc.element.async.times">
        function <span class="apidocSignatureSpan">async.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: &apos;user&apos; + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timesLimit" id="apidoc.element.async.timesLimit">
        function <span class="apidocSignatureSpan">async.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.timesSeries" id="apidoc.element.async.timesSeries">
        function <span class="apidocSignatureSpan">async.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.transform" id="apidoc.element.async.transform">
        function <span class="apidocSignatureSpan">async.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);

    eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function(err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.tryEach" id="apidoc.element.async.tryEach">
        function <span class="apidocSignatureSpan">async.</span>tryEach
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || noop;
    eachSeries(tasks, function(task, callback) {
        wrapAsync(task)(function (err, res/*, ...args*/) {
            if (arguments.length &gt; 2) {
                result = slice(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* completion with an error `err` (which can be `null`) and an optional `result`
* value.
* @param {Function} [callback] - An optional callback which is called when one
* of the tasks has succeeded, or all have failed. It receives the `err` and
* `result` arguments of the last attempt at completing the `task`. Invoked with
* (err, results).
* @example
* async.<span class="apidocCodeKeywordSpan">tryEach</span>([
*     function getDataFromFirstWebsite(callback) {
*         // Try getting the data from the first website
*         callback(err, data);
*     },
*     function getDataFromSecondWebsite(callback) {
*         // First website failed,
*         // Try getting the data from the backup website
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.unmemoize" id="apidoc.element.async.unmemoize">
        function <span class="apidocSignatureSpan">async.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.until" id="apidoc.element.async.until">
        function <span class="apidocSignatureSpan">async.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    whilst(function() {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.waterfall" id="apidoc.element.async.waterfall">
        function <span class="apidocSignatureSpan">async.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error(&apos;First argument to waterfall must be an array of functions&apos;));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
    }

    function next(err/*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous function, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.whilst" id="apidoc.element.async.whilst">
        function <span class="apidocSignatureSpan">async.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    if (!test()) return callback(null);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`&apos;s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.wrapSync" id="apidoc.element.async.wrapSync">
        function <span class="apidocSignatureSpan">async.</span>wrapSync
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.DoublyLinkedList" id="apidoc.module.async.DoublyLinkedList">module async.DoublyLinkedList</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.DoublyLinkedList" id="apidoc.element.async.DoublyLinkedList.DoublyLinkedList">
        function <span class="apidocSignatureSpan">async.</span>DoublyLinkedList
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DLL() {
    this.head = this.tail = null;
    this.length = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.DoublyLinkedList.prototype" id="apidoc.module.async.DoublyLinkedList.prototype">module async.DoublyLinkedList.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.empty" id="apidoc.element.async.DoublyLinkedList.prototype.empty">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
    while (this.head) this.shift();
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# v2.4.0
- Added `tryEach`, for running async functions in parallel, where you only expect one to succeed. ([#1365](https://github.com/caolan
/async/issues/1365), [#687](https://github.com/caolan/async/issues/687))
- Improved performance, most notably in `parallel` and `waterfall` ([#1395](https://github.com/caolan/async/issues/1395))
- Added `queue.remove()`, for removing items in a `queue` ([#1397](https://github.com/caolan/async/issues/1397), [#1391](https://
github.com/caolan/async/issues/1391))
- Fixed using `eval`, preventing Async from running in pages with Content Security Policy ([#1404](https://github.com/caolan/async
/issues/1404), [#1403](https://github.com/caolan/async/issues/1403))
- Fixed errors thrown in an `asyncify`ed function&apos;s callback being caught by the underlying Promise ([#1408](https://github
.com/caolan/async/issues/1408))
- Fixed timing of `queue.<span class="apidocCodeKeywordSpan">empty</span>()` ([#1367](https://github.com/caolan/async/issues/1367
))
- Various doc fixes ([#1314](https://github.com/caolan/async/issues/1314), [#1394](https://github.com/caolan/async/issues/1394), [#
1412](https://github.com/caolan/async/issues/1412))

# v2.3.0
- Added support for ES2017 `async` functions.  Wherever you can pass a Node-style/CPS function that uses a callback, you can also
 pass an `async` function.  Previously, you had to wrap `async` functions with `asyncify`.  The caveat is that it will only work
 if `async` functions are supported natively in your environment, transpiled implementations can&apos;t be detected.  ([#1386](https
://github.com/caolan/async/issues/1386), [#1390](https://github.com/caolan/async/issues/1390))
- Small doc fix ([#1392](https://github.com/caolan/async/issues/1392))

# v2.2.0
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.insertAfter" id="apidoc.element.async.DoublyLinkedList.prototype.insertAfter">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(node, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next) node.next.prev = newNode;else this.tail = newNode;
    node.next = newNode;
    this.length += 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

DLL.prototype.unshift = function(node) {
    if (this.head) this.insertBefore(this.head, node);
    else setInitial(this, node);
};

DLL.prototype.push = function(node) {
    if (this.tail) this.<span class="apidocCodeKeywordSpan">insertAfter</span>(this.tail, node);
    else setInitial(this, node);
};

DLL.prototype.shift = function() {
    return this.head &amp;&amp; this.removeLink(this.head);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.insertBefore" id="apidoc.element.async.DoublyLinkedList.prototype.insertBefore">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(node, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertBefore = function (node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev) node.prev.next = newNode;else this.head = newNode;
    node.prev = newNode;
    this.length += 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var item = {
            data: data[i],
            priority: priority,
            callback: callback
        };

        if (nextNode) {
            q._tasks.<span class="apidocCodeKeywordSpan">insertBefore</span>(nextNode, item);
        } else {
            q._tasks.push(item);
        }
    }
    (0, _setImmediate2.default)(q.process);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.pop" id="apidoc.element.async.DoublyLinkedList.prototype.pop">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
    return this.tail &amp;&amp; this.removeLink(this.tail);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
    params = parseParams(taskFn);
    if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
        throw new Error(&quot;autoInject task functions require explicit parameters.&quot;);
    }

    // remove callback param
    if (!fnIsAsync) params.<span class="apidocCodeKeywordSpan">pop</span>();

    newTasks[key] = params.concat(newTask);
}

function newTask(results, taskCb) {
    var newArgs = (0, _arrayMap2.default)(params, function (name) {
        return results[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.push" id="apidoc.element.async.DoublyLinkedList.prototype.push">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (node) {
    if (this.tail) this.insertAfter(this.tail, node);else setInitial(this, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.<span class="apidocCodeKeywordSpan">push</span>(files);
 */
function asyncify(func) {
return (0, _initialParams2.default)(function (args, callback) {
    var result;
    try {
        result = func.apply(this, args);
    } catch (e) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.remove" id="apidoc.element.async.DoublyLinkedList.prototype.remove">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>remove
        <span class="apidocSignatureSpan">(testFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (testFn) {
    var curr = this.head;
    while (!!curr) {
        var next = curr.next;
        if (testFn(curr)) {
            this.removeLink(curr);
        }
        curr = next;
    }
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

# v2.4.1
- Fixed a bug preventing functions wrapped  with `timeout()` from being re-used. ([#1418](https://github.com/caolan/async/issues
/1418), [#1419](https://github.com/caolan/async/issues/1419))

# v2.4.0
- Added `tryEach`, for running async functions in parallel, where you only expect one to succeed. ([#1365](https://github.com/caolan
/async/issues/1365), [#687](https://github.com/caolan/async/issues/687))
- Improved performance, most notably in `parallel` and `waterfall` ([#1395](https://github.com/caolan/async/issues/1395))
- Added `queue.<span class="apidocCodeKeywordSpan">remove</span>()`, for removing items in a `queue` ([#1397](https://github.com
/caolan/async/issues/1397), [#1391](https://github.com/caolan/async/issues/1391))
- Fixed using `eval`, preventing Async from running in pages with Content Security Policy ([#1404](https://github.com/caolan/async
/issues/1404), [#1403](https://github.com/caolan/async/issues/1403))
- Fixed errors thrown in an `asyncify`ed function&apos;s callback being caught by the underlying Promise ([#1408](https://github
.com/caolan/async/issues/1408))
- Fixed timing of `queue.empty()` ([#1367](https://github.com/caolan/async/issues/1367))
- Various doc fixes ([#1314](https://github.com/caolan/async/issues/1314), [#1394](https://github.com/caolan/async/issues/1394), [#
1412](https://github.com/caolan/async/issues/1412))

# v2.3.0
- Added support for ES2017 `async` functions.  Wherever you can pass a Node-style/CPS function that uses a callback, you can also
 pass an `async` function.  Previously, you had to wrap `async` functions with `asyncify`.  The caveat is that it will only work
 if `async` functions are supported natively in your environment, transpiled implementations can&apos;t be detected.  ([#1386](https
://github.com/caolan/async/issues/1386), [#1390](https://github.com/caolan/async/issues/1390))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.removeLink" id="apidoc.element.async.DoublyLinkedList.prototype.removeLink">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>removeLink
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeLink = function (node) {
    if (node.prev) node.prev.next = node.next;else this.head = node.next;
    if (node.next) node.next.prev = node.prev;else this.tail = node.prev;

    node.prev = node.next = null;
    this.length -= 1;
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

DLL.prototype.push = function(node) {
    if (this.tail) this.insertAfter(this.tail, node);
    else setInitial(this, node);
};

DLL.prototype.shift = function() {
    return this.head &amp;&amp; this.<span class="apidocCodeKeywordSpan">removeLink</span>(this.head);
};

DLL.prototype.pop = function() {
    return this.tail &amp;&amp; this.removeLink(this.tail);
};

DLL.prototype.toArray = function () {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.shift" id="apidoc.element.async.DoublyLinkedList.prototype.shift">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shift = function () {
    return this.head &amp;&amp; this.removeLink(this.head);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function processQueue() {
    if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
        return callback(null, results);
    }
    while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
        var run = readyTasks.<span class="apidocCodeKeywordSpan">shift</span>();
        run();
    }
}

function addListener(taskName, fn) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.toArray" id="apidoc.element.async.DoublyLinkedList.prototype.toArray">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
    var arr = Array(this.length);
    var curr = this.head;
    for (var idx = 0; idx &lt; this.length; idx++) {
        arr[idx] = curr.data;
        curr = curr.next;
    }
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.DoublyLinkedList.prototype.unshift" id="apidoc.element.async.DoublyLinkedList.prototype.unshift">
        function <span class="apidocSignatureSpan">async.DoublyLinkedList.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unshift = function (node) {
    if (this.head) this.insertBefore(this.head, node);else setInitial(this, node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* functions should be run in parallel. This property can be changed after a
* `queue` is created to alter the concurrency on-the-fly.
* @property {Function} push - add a new task to the `queue`. Calls `callback`
* once the `worker` has finished processing the task. Instead of a single task,
* a `tasks` array can be submitted. The respective callback is used for every
* task in the list. Invoke with `queue.push(task, [callback])`,
* @property {Function} unshift - add a new task to the front of the `queue`.
* Invoke with `queue.<span class="apidocCodeKeywordSpan">unshift</span>(task, [callback])`.
* @property {Function} remove - remove items from the queue that match a test
* function.  The test function will be passed an object with a `data` property,
* and a `priority` property, if this is a
* [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
* Invoked with `queue.remove(testFn)`, where `testFn` is of the form
* `function ({data, priority}) {}` and returns a Boolean.
* @property {Function} saturated - a callback that is called when the number of
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.default" id="apidoc.module.async.default">module async.default</a></h1>


    <h2>
        <a href="#apidoc.element.async.default.all" id="apidoc.element.async.default.all">
        function <span class="apidocSignatureSpan">async.default.</span>all
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.allLimit" id="apidoc.element.async.default.allLimit">
        function <span class="apidocSignatureSpan">async.default.</span>allLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.allSeries" id="apidoc.element.async.default.allSeries">
        function <span class="apidocSignatureSpan">async.default.</span>allSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.any" id="apidoc.element.async.default.any">
        function <span class="apidocSignatureSpan">async.default.</span>any
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.anyLimit" id="apidoc.element.async.default.anyLimit">
        function <span class="apidocSignatureSpan">async.default.</span>anyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.anySeries" id="apidoc.element.async.default.anySeries">
        function <span class="apidocSignatureSpan">async.default.</span>anySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.apply" id="apidoc.element.async.default.apply">
        function <span class="apidocSignatureSpan">async.default.</span>apply
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (fn) {
    var args = slice(arguments, 1);
    return function(/*callArgs*/) {
        var callArgs = slice(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args.concat(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.applyEach" id="apidoc.element.async.default.applyEach">
        function <span class="apidocSignatureSpan">async.default.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function (fns) {
    var args = slice(arguments, 1);
    var go = initialParams(function(args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            wrapAsync(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    }
    else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], &apos;bucket&apos;, callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.applyEachSeries" id="apidoc.element.async.default.applyEachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function (fns) {
    var args = slice(arguments, 1);
    var go = initialParams(function(args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            wrapAsync(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    }
    else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.asyncify" id="apidoc.element.async.default.asyncify">
        function <span class="apidocSignatureSpan">async.default.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.auto" id="apidoc.element.async.default.auto">
        function <span class="apidocSignatureSpan">async.default.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === &apos;function&apos;) {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = once(callback || noop);
    var keys$$1 = keys(tasks);
    var numTasks = keys$$1.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    baseForOwn(tasks, function (task, key) {
        if (!isArray(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        arrayEach(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error(&apos;async.auto task `&apos; + key +
                    &apos;` has a non-existent dependency `&apos; +
                    dependencyName + &apos;` in &apos; +
                    dependencies.join(&apos;, &apos;));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while(readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }

    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        arrayEach(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }


    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = onlyOnce(function(err, result) {
            runningTasks--;
            if (arguments.length &gt; 2) {
                result = slice(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn&apos;s algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
        var currentTask;
        var counter = 0;...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, &apos;data.txt&apos;, &apos;utf-8&apos;),
*     showData: [&apos;readData&apos;, function(results, cb) {
*         // results.readData is the file&apos;s contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.autoInject" id="apidoc.element.async.default.autoInject">
        function <span class="apidocSignatureSpan">async.default.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    baseForOwn(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = isAsync(taskFn);
        var hasNoDeps =
            (!fnIsAsync &amp;&amp; taskFn.length === 1) ||
            (fnIsAsync &amp;&amp; taskFn.length === 0);

        if (isArray(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error(&quot;autoInject task functions require explicit parameters.&quot;);
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = arrayMap(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            wrapAsync(taskFn).apply(null, newArgs);
        }
    });

    auto(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, &apos;data&apos;, &apos;converted to array&apos;);
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.cargo" id="apidoc.element.async.default.cargo">
        function <span class="apidocSignatureSpan">async.default.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
    return queue(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log(&apos;hello &apos; + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.compose" id="apidoc.element.async.default.compose">
        function <span class="apidocSignatureSpan">async.default.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () {
    return seq.apply(null, slice(arguments).reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.concat" id="apidoc.element.async.default.concat">
        function <span class="apidocSignatureSpan">async.default.</span>concat
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.concatLimit" id="apidoc.element.async.default.concatLimit">
        function <span class="apidocSignatureSpan">async.default.</span>concatLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, slice(arguments, 1));
        });
    }, function(err, mapResults) {
        var result = [];
        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.concatSeries" id="apidoc.element.async.default.concatSeries">
        function <span class="apidocSignatureSpan">async.default.</span>concatSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.constant" id="apidoc.element.async.default.constant">
        function <span class="apidocSignatureSpan">async.default.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () {
    var values = slice(arguments);
    var args = [null].concat(values);
    return function (/*...ignoredArgs, callback*/) {
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detect" id="apidoc.element.async.default.detect">
        function <span class="apidocSignatureSpan">async.default.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detectLimit" id="apidoc.element.async.default.detectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.detectSeries" id="apidoc.element.async.default.detectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.dir" id="apidoc.element.async.default.dir">
        function <span class="apidocSignatureSpan">async.default.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
    var args = slice(arguments, 1);
    args.push(function (err/*, ...args*/) {
        var args = slice(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                arrayEach(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    wrapAsync(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, &apos;world&apos;);
 * {hello: &apos;world&apos;}
 */
exports.default = (0, _consoleFunc2.default)(&apos;dir&apos;);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doDuring" id="apidoc.element.async.default.doDuring">
        function <span class="apidocSignatureSpan">async.default.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doUntil" id="apidoc.element.async.default.doUntil">
        function <span class="apidocSignatureSpan">async.default.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    doWhilst(iteratee, function() {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.doWhilst" id="apidoc.element.async.default.doWhilst">
        function <span class="apidocSignatureSpan">async.default.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        var args = slice(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.during" id="apidoc.element.async.default.during">
        function <span class="apidocSignatureSpan">async.default.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = onlyOnce(callback || noop);
    var _fn = wrapAsync(fn);
    var _test = wrapAsync(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.each" id="apidoc.element.async.default.each">
        function <span class="apidocSignatureSpan">async.default.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], &apos;bucket&apos;, callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachLimit" id="apidoc.element.async.default.eachLimit">
        function <span class="apidocSignatureSpan">async.default.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOf" id="apidoc.element.async.default.eachOf">
        function <span class="apidocSignatureSpan">async.default.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOfLimit" id="apidoc.element.async.default.eachOfLimit">
        function <span class="apidocSignatureSpan">async.default.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachOfSeries" id="apidoc.element.async.default.eachOfSeries">
        function <span class="apidocSignatureSpan">async.default.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.eachSeries" id="apidoc.element.async.default.eachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.ensureAsync" id="apidoc.element.async.default.ensureAsync">
        function <span class="apidocSignatureSpan">async.default.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if (isAsync(fn)) return fn;
    return initialParams(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                setImmediate$1(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
3. The callback can accept any number of arguments
4. The first argument passed to the callback will be treated as an error result, if the argument is truthy
5. Any number of result arguments can be passed after the &quot;error&quot; argument
6. The callback is called once and exactly once, either on the same tick or later tick of the JavaScript event loop.

There were several cases where Async accepted some functions that did not strictly have these properties, most notably `auto`, `
every`, `some`, `filter`, `reject` and `detect`.

Another theme is performance. We have eliminated internal deferrals in all cases where they make sense. For example, in `waterfall
` and `auto`, there was a `setImmediate` between each task -- these deferrals have been removed. A `setImmediate` call can add up
 to 1ms of delay. This might not seem like a lot, but it can add up if you are using many Async functions in the course of processing
 a HTTP request, for example. Nearly all asynchronous functions that do I/O already have some sort of deferral built in, so the
extra deferral is unnecessary. The trade-off of this change is removing our built-in stack-overflow defense. Many synchronous callback
 calls in series can quickly overflow the JS call stack. If you do have a function that is sometimes synchronous (calling its callback
 on the same tick), and are running into stack overflows, wrap it with `async.<span class="apidocCodeKeywordSpan">ensureAsync</span
>()`.

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.every" id="apidoc.element.async.default.every">
        function <span class="apidocSignatureSpan">async.default.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.everyLimit" id="apidoc.element.async.default.everyLimit">
        function <span class="apidocSignatureSpan">async.default.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.everySeries" id="apidoc.element.async.default.everySeries">
        function <span class="apidocSignatureSpan">async.default.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filter" id="apidoc.element.async.default.filter">
        function <span class="apidocSignatureSpan">async.default.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filterLimit" id="apidoc.element.async.default.filterLimit">
        function <span class="apidocSignatureSpan">async.default.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.filterSeries" id="apidoc.element.async.default.filterSeries">
        function <span class="apidocSignatureSpan">async.default.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.find" id="apidoc.element.async.default.find">
        function <span class="apidocSignatureSpan">async.default.</span>find
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.findLimit" id="apidoc.element.async.default.findLimit">
        function <span class="apidocSignatureSpan">async.default.</span>findLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.findSeries" id="apidoc.element.async.default.findSeries">
        function <span class="apidocSignatureSpan">async.default.</span>findSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.foldl" id="apidoc.element.async.default.foldl">
        function <span class="apidocSignatureSpan">async.default.</span>foldl
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.foldr" id="apidoc.element.async.default.foldr">
        function <span class="apidocSignatureSpan">async.default.</span>foldr
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEach" id="apidoc.element.async.default.forEach">
        function <span class="apidocSignatureSpan">async.default.</span>forEach
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachLimit" id="apidoc.element.async.default.forEachLimit">
        function <span class="apidocSignatureSpan">async.default.</span>forEachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit$1(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOf" id="apidoc.element.async.default.forEachOf">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called when all
* `iteratee` functions have finished, or an error occurs. Invoked with (err).
* @example
*
* var obj = {dev: &quot;/dev.json&quot;, test: &quot;/test.json&quot;, prod: &quot;/prod.json&quot;};
* var configs = {};
*
* async.<span class="apidocCodeKeywordSpan">forEachOf</span>(obj, function (value, key, callback) {
*     fs.readFile(__dirname + value, &quot;utf8&quot;, function (err, data) {
*         if (err) return callback(err);
*         try {
*             configs[key] = JSON.parse(data);
*         } catch (e) {
*             return callback(e);
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOfLimit" id="apidoc.element.async.default.forEachOfLimit">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachOfSeries" id="apidoc.element.async.default.forEachOfSeries">
        function <span class="apidocSignatureSpan">async.default.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forEachSeries" id="apidoc.element.async.default.forEachSeries">
        function <span class="apidocSignatureSpan">async.default.</span>forEachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.forever" id="apidoc.element.async.default.forever">
        function <span class="apidocSignatureSpan">async.default.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = onlyOnce(errback || noop);
    var task = wrapAsync(ensureAsync(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it&apos;s callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as &apos;err&apos;, and execution will stop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupBy" id="apidoc.element.async.default.groupBy">
        function <span class="apidocSignatureSpan">async.default.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>([&apos;userId1&apos;, &apos;userId2&apos;, &apos;userId3&apos;], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: [&apos;userId1&apos;, &apos;userId3&apos;], 42: [&apos;userId2&apos;]};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupByLimit" id="apidoc.element.async.default.groupByLimit">
        function <span class="apidocSignatureSpan">async.default.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || noop;
    var _iteratee = wrapAsync(iteratee);
    mapLimit(coll, limit, function(val, callback) {
        _iteratee(val, function(err, key) {
            if (err) return callback(err);
            return callback(null, {key: key, val: val});
        });
    }, function(err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.groupBySeries" id="apidoc.element.async.default.groupBySeries">
        function <span class="apidocSignatureSpan">async.default.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.inject" id="apidoc.element.async.default.inject">
        function <span class="apidocSignatureSpan">async.default.</span>inject
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.log" id="apidoc.element.async.default.log">
        function <span class="apidocSignatureSpan">async.default.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
    var args = slice(arguments, 1);
    args.push(function (err/*, ...args*/) {
        var args = slice(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                arrayEach(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    wrapAsync(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     },
*     email_link: function(write_file, callback) {
*         // once the file is written let&apos;s email a link to it...
*         // write_file contains the filename returned by write_file.
*         callback(null, {&apos;file&apos;:write_file, &apos;email&apos;:&apos;user@example.com&apos;});
*     }
* }, function(err, results) {
*     console.<span class="apidocCodeKeywordSpan">log</span>(&apos;err = &apos;, err);
*     console.log(&apos;email_link = &apos;, results.email_link);
* });
*
* // If you are using a JS minifier that mangles parameter names, `autoInject`
* // will not work with plain functions, since the parameter names will be
* // collapsed to a single letter identifier.  To work around this, you can
* // explicitly specify the names of the parameters your task function needs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.map" id="apidoc.element.async.default.map">
        function <span class="apidocSignatureSpan">async.default.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, &apos;&apos;);
   func = func.match(FN_ARGS)[2].replace(&apos; &apos;, &apos;&apos;);
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, &apos;&apos;));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapLimit" id="apidoc.element.async.default.mapLimit">
        function <span class="apidocSignatureSpan">async.default.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

```javascript
var async = require(&quot;async&quot;);

// ...or ES2017 async functions
async.<span class="apidocCodeKeywordSpan">mapLimit</span>(urls, 5, async function(url) {
    const response = await fetch(url)
    return response.body
}, (err, results) =&gt; {
    if (err) throw err
    // results is now an array of the response bodies
    console.log(results)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapSeries" id="apidoc.element.async.default.mapSeries">
        function <span class="apidocSignatureSpan">async.default.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync&apos;s callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValues" id="apidoc.element.async.default.mapValues">
        function <span class="apidocSignatureSpan">async.default.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: &apos;file1&apos;,
*     f2: &apos;file2&apos;,
*     f3: &apos;file3&apos;
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValuesLimit" id="apidoc.element.async.default.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.default.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = once(callback || noop);
    var newObj = {};
    var _iteratee = wrapAsync(iteratee);
    eachOfLimit(obj, limit, function(val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.mapValuesSeries" id="apidoc.element.async.default.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.default.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.memoize" id="apidoc.element.async.default.memoize">
        function <span class="apidocSignatureSpan">async.default.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || identity;
    var _fn = wrapAsync(fn);
    var memoized = initialParams(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            setImmediate$1(function() {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function(/*args*/) {
                var args = slice(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn(&apos;some name&apos;, function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.nextTick" id="apidoc.element.async.default.nextTick">
        function <span class="apidocSignatureSpan">async.default.</span>nextTick
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function (fn) {
    var args = slice(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.parallel" id="apidoc.element.async.default.parallel">
        function <span class="apidocSignatureSpan">async.default.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
    _parallel(eachOf, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @returns {Function} the partially-applied function
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, &apos;testfile1&apos;, &apos;test1&apos;),
*     async.apply(fs.writeFile, &apos;testfile2&apos;, &apos;test2&apos;)
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.parallelLimit" id="apidoc.element.async.default.parallelLimit">
        function <span class="apidocSignatureSpan">async.default.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit$1(tasks, limit, callback) {
    _parallel(_eachOfLimit(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.priorityQueue" id="apidoc.element.async.default.priorityQueue">
        function <span class="apidocSignatureSpan">async.default.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = queue$1(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function(data, priority, callback) {
        if (callback == null) callback = noop;
        if (typeof callback !== &apos;function&apos;) {
            throw new Error(&apos;task callback must be a function&apos;);
        }
        q.started = true;
        if (!isArray(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return setImmediate$1(function() {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        setImmediate$1(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.queue" id="apidoc.element.async.default.queue">
        function <span class="apidocSignatureSpan">async.default.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
    var _worker = wrapAsync(worker);
    return queue(function (items, cb) {
        _worker(items[0], cb);
    }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.race" id="apidoc.element.async.default.race">
        function <span class="apidocSignatureSpan">async.default.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new TypeError(&apos;First argument to race must be an array of functions&apos;));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        wrapAsync(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`. It will run an array of async tasks in
 parallel and will call its callback with the result of the first task to respond. ([#568](https://github.com/caolan/async/issues
/568), [#1038](https://github.com/caolan/async/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.reflect()`](http://bluebirdjs.com/docs/api/reflect.html), a wrapper for
 async tasks that always succeeds, by gathering results and errors into an object.  ([#942](https://github.com/caolan/async/issues
/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reduce" id="apidoc.element.async.default.reduce">
        function <span class="apidocSignatureSpan">async.default.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    eachOfSeries(coll, function(x, i, callback) {
        _iteratee(memo, x, function(err, v) {
            memo = v;
            callback(err);
        });
    }, function(err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reduceRight" id="apidoc.element.async.default.reduceRight">
        function <span class="apidocSignatureSpan">async.default.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
    var reversed = slice(array).reverse();
    reduce(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reflect" id="apidoc.element.async.default.reflect">
        function <span class="apidocSignatureSpan">async.default.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = wrapAsync(fn);
    return initialParams(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length &lt;= 2) {
                    value = cbArg;
                } else {
                    value = slice(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.race()`. It will run an array of async tasks in parallel and will call its callback with the
 result of the first task to respond. ([#568](https://github.com/caolan/async/issues/568), [#1038](https://github.com/caolan/async
/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.<span class="apidocCodeKeywordSpan">reflect</span>()`](http://bluebirdjs
.com/docs/api/reflect.html), a wrapper for async tasks that always succeeds, by gathering results and errors into an object.  ([#
942](https://github.com/caolan/async/issues/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com
/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
- Added `autoInject`, a relative of `auto` that automatically spreads a task&apos;s dependencies as arguments to the task function
. ([#608](https://github.com/caolan/async/issues/608), [#1055](https://github.com/caolan/async/issues/1055), [#1099](https://github
.com/caolan/async/issues/1099), [#1100](https://github.com/caolan/async/issues/1100))
- You can now limit the concurrency of `auto` tasks. ([#635](https://github.com/caolan/async/issues/635), [#637](https://github.
com/caolan/async/issues/637))
- Added `retryable`, a relative of `retry` that wraps an async function, making it retry when called. ([#1058](https://github.com
/caolan/async/issues/1058))
- `retry` now supports specifying a function that determines the next time interval, useful for exponential backoff, logging and
 other retry strategies. ([#1161](https://github.com/caolan/async/issues/1161))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reflectAll" id="apidoc.element.async.default.reflectAll">
        function <span class="apidocSignatureSpan">async.default.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if (isArray(tasks)) {
        results = arrayMap(tasks, reflect);
    } else {
        results = {};
        baseForOwn(tasks, function(task, key) {
            results[key] = reflect.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, &apos;two&apos;);
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = &apos;one&apos;
*     // results[1].error = Error(&apos;bad stuff happened&apos;)
*     // results[2].value = &apos;two&apos;
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.reject" id="apidoc.element.async.default.reject">
        function <span class="apidocSignatureSpan">async.default.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `coll`.
* The should complete with a boolean value as its `result`.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reject</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of missing files
*     createFiles(results);
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.rejectLimit" id="apidoc.element.async.default.rejectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.rejectSeries" id="apidoc.element.async.default.rejectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.retry" id="apidoc.element.async.default.retry">
        function <span class="apidocSignatureSpan">async.default.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant$1(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === &apos;object&apos;) {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === &apos;function&apos; ?
                t.interval :
                constant$1(+t.interval || DEFAULT_INTERVAL);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === &apos;number&apos; || typeof t === &apos;string&apos;) {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error(&quot;Invalid arguments for async.retry&quot;);
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === &apos;function&apos;) {
        callback = task || noop;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || noop;
    }

    if (typeof task !== &apos;function&apos;) {
        throw new Error(&quot;Invalid arguments for async.retry&quot;);
    }

    var _task = wrapAsync(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function(err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp;
                (typeof options.errorFilter != &apos;function&apos; ||
                    options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.retryable" id="apidoc.element.async.default.retryable">
        function <span class="apidocSignatureSpan">async.default.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = wrapAsync(task);
    return initialParams(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) retry(opts, taskFn, callback);
        else retry(taskFn, callback);

    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (...args, callback).
* @returns {AsyncFunction} The wrapped function, which when invoked, will
* retry on an error, based on the parameters specified in `opts`.
* This function will accept the same parameters as `task`.
* @example
*
* async.auto({
*     dep1: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, getFromFlakyService),
*     process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {
*         maybeProcessData(results.dep1, cb);
*     })]
* }, callback);
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.select" id="apidoc.element.async.default.select">
        function <span class="apidocSignatureSpan">async.default.</span>select
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.selectLimit" id="apidoc.element.async.default.selectLimit">
        function <span class="apidocSignatureSpan">async.default.</span>selectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.selectSeries" id="apidoc.element.async.default.selectSeries">
        function <span class="apidocSignatureSpan">async.default.</span>selectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.seq" id="apidoc.element.async.default.seq">
        function <span class="apidocSignatureSpan">async.default.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() {
    var _functions = arrayMap(arguments, wrapAsync);
    return function(/*...args*/) {
        var args = slice(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == &apos;function&apos;) {
            args.pop();
        } else {
            cb = noop;
        }

        reduce(_functions, args, function(newargs, fn, cb) {
            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
                var nextargs = slice(arguments, 1);
                cb(err, nextargs);
            }));
        },
        function(err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende&apos;s orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get(&apos;/cats&apos;, function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // &apos;User.get&apos; has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // &apos;getCats&apos; has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.series" id="apidoc.element.async.default.series">
        function <span class="apidocSignatureSpan">async.default.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
    _parallel(eachOfSeries, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, &apos;one&apos;);
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, &apos;two&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.setImmediate" id="apidoc.element.async.default.setImmediate">
        function <span class="apidocSignatureSpan">async.default.</span>setImmediate
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (fn) {
    var args = slice(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push(&apos;two&apos;);
 *     // call_order now equals [&apos;one&apos;,&apos;two&apos;]
 * });
 * call_order.push(&apos;one&apos;);
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.some" id="apidoc.element.async.default.some">
        function <span class="apidocSignatureSpan">async.default.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(eachOf, obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.someLimit" id="apidoc.element.async.default.someLimit">
        function <span class="apidocSignatureSpan">async.default.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.someSeries" id="apidoc.element.async.default.someSeries">
        function <span class="apidocSignatureSpan">async.default.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.sortBy" id="apidoc.element.async.default.sortBy">
        function <span class="apidocSignatureSpan">async.default.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    map(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, {value: x, criteria: criteria});
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, arrayMap(results.sort(comparator), baseProperty(&apos;value&apos;)));
    });

    function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timeout" id="apidoc.element.async.default.timeout">
        function <span class="apidocSignatureSpan">async.default.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var fn = wrapAsync(asyncFn);

    return initialParams(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || &apos;anonymous&apos;;
            var error  = new Error(&apos;Callback function &quot;&apos; + name + &apos;&quot; timed out.&apos;);
            error.code = &apos;ETIMEDOUT&apos;;
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: &apos;bar&apos; }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code &apos;ETIMEDOUT&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.times" id="apidoc.element.async.default.times">
        function <span class="apidocSignatureSpan">async.default.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: &apos;user&apos; + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timesLimit" id="apidoc.element.async.default.timesLimit">
        function <span class="apidocSignatureSpan">async.default.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
    var _iteratee = wrapAsync(iteratee);
    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.timesSeries" id="apidoc.element.async.default.timesSeries">
        function <span class="apidocSignatureSpan">async.default.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.transform" id="apidoc.element.async.default.transform">
        function <span class="apidocSignatureSpan">async.default.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = isArray(coll) ? [] : {};
    }
    callback = once(callback || noop);
    var _iteratee = wrapAsync(iteratee);

    eachOf(coll, function(v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function(err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.tryEach" id="apidoc.element.async.default.tryEach">
        function <span class="apidocSignatureSpan">async.default.</span>tryEach
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || noop;
    eachSeries(tasks, function(task, callback) {
        wrapAsync(task)(function (err, res/*, ...args*/) {
            if (arguments.length &gt; 2) {
                result = slice(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* completion with an error `err` (which can be `null`) and an optional `result`
* value.
* @param {Function} [callback] - An optional callback which is called when one
* of the tasks has succeeded, or all have failed. It receives the `err` and
* `result` arguments of the last attempt at completing the `task`. Invoked with
* (err, results).
* @example
* async.<span class="apidocCodeKeywordSpan">tryEach</span>([
*     function getDataFromFirstWebsite(callback) {
*         // Try getting the data from the first website
*         callback(err, data);
*     },
*     function getDataFromSecondWebsite(callback) {
*         // First website failed,
*         // Try getting the data from the backup website
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.unmemoize" id="apidoc.element.async.default.unmemoize">
        function <span class="apidocSignatureSpan">async.default.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.until" id="apidoc.element.async.default.until">
        function <span class="apidocSignatureSpan">async.default.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    whilst(function() {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.waterfall" id="apidoc.element.async.default.waterfall">
        function <span class="apidocSignatureSpan">async.default.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = once(callback || noop);
    if (!isArray(tasks)) return callback(new Error(&apos;First argument to waterfall must be an array of functions&apos;));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        args.push(onlyOnce(next));
        task.apply(null, args);
    }

    function next(err/*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask(slice(arguments, 1));
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous function, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.whilst" id="apidoc.element.async.default.whilst">
        function <span class="apidocSignatureSpan">async.default.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = onlyOnce(callback || noop);
    var _iteratee = wrapAsync(iteratee);
    if (!test()) return callback(null);
    var next = function(err/*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = slice(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`&apos;s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.default.wrapSync" id="apidoc.element.async.default.wrapSync">
        function <span class="apidocSignatureSpan">async.default.</span>wrapSync
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return initialParams(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (isObject(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function(value) {
                invokeCallback(callback, null, value);
            }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.index" id="apidoc.module.async.index">module async.index</a></h1>


    <h2>
        <a href="#apidoc.element.async.index.all" id="apidoc.element.async.index.all">
        function <span class="apidocSignatureSpan">async.index.</span>all
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.allLimit" id="apidoc.element.async.index.allLimit">
        function <span class="apidocSignatureSpan">async.index.</span>allLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.allSeries" id="apidoc.element.async.index.allSeries">
        function <span class="apidocSignatureSpan">async.index.</span>allSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.any" id="apidoc.element.async.index.any">
        function <span class="apidocSignatureSpan">async.index.</span>any
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">any = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.anyLimit" id="apidoc.element.async.index.anyLimit">
        function <span class="apidocSignatureSpan">async.index.</span>anyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.anySeries" id="apidoc.element.async.index.anySeries">
        function <span class="apidocSignatureSpan">async.index.</span>anySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.apply" id="apidoc.element.async.index.apply">
        function <span class="apidocSignatureSpan">async.index.</span>apply
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply = function (fn) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.apply(null, args.concat(callArgs));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.<span class="apidocCodeKeywordSpan">apply</span>(null, args.concat(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.applyEach" id="apidoc.element.async.index.applyEach">
        function <span class="apidocSignatureSpan">async.index.</span>applyEach
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEach = function (fns) {
    var args = (0, _slice2.default)(arguments, 1);
    var go = (0, _initialParams2.default)(function (args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            (0, _wrapAsync2.default)(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    } else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* called when all functions have completed processing.
* @returns {Function} - If only the first argument, `fns`, is provided, it will
* return a function which lets you pass in the arguments as if it were a single
* function call. The signature is `(..args, callback)`. If invoked with any
* arguments, `callback` is required.
* @example
*
* async.<span class="apidocCodeKeywordSpan">applyEach</span>([enableSearch, updateSchema], &apos;bucket&apos;, callback);
*
* // partial application example:
* async.each(
*     buckets,
*     async.applyEach([enableSearch, updateSchema]),
*     callback
* );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.applyEachSeries" id="apidoc.element.async.index.applyEachSeries">
        function <span class="apidocSignatureSpan">async.index.</span>applyEachSeries
        <span class="apidocSignatureSpan">(fns)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyEachSeries = function (fns) {
    var args = (0, _slice2.default)(arguments, 1);
    var go = (0, _initialParams2.default)(function (args, callback) {
        var that = this;
        return eachfn(fns, function (fn, cb) {
            (0, _wrapAsync2.default)(fn).apply(that, args.concat(cb));
        }, callback);
    });
    if (args.length) {
        return go.apply(this, args);
    } else {
        return go;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.asyncify" id="apidoc.element.async.index.asyncify">
        function <span class="apidocSignatureSpan">async.index.</span>asyncify
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if ((0, _isObject2.default)(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function (value) {
                invokeCallback(callback, null, value);
            }, function (err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.waterfall([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.<span class="apidocCodeKeywordSpan">asyncify</span>(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
*
* // passing a function returning a promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.auto" id="apidoc.element.async.index.auto">
        function <span class="apidocSignatureSpan">async.index.</span>auto
        <span class="apidocSignatureSpan">(tasks, concurrency, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">auto = function (tasks, concurrency, callback) {
    if (typeof concurrency === &apos;function&apos;) {
        // concurrency is optional, shift the args.
        callback = concurrency;
        concurrency = null;
    }
    callback = (0, _once2.default)(callback || _noop2.default);
    var keys = (0, _keys2.default)(tasks);
    var numTasks = keys.length;
    if (!numTasks) {
        return callback(null);
    }
    if (!concurrency) {
        concurrency = numTasks;
    }

    var results = {};
    var runningTasks = 0;
    var hasError = false;

    var listeners = Object.create(null);

    var readyTasks = [];

    // for cycle detection:
    var readyToCheck = []; // tasks that have been identified as reachable
    // without the possibility of returning to an ancestor task
    var uncheckedDependencies = {};

    (0, _baseForOwn2.default)(tasks, function (task, key) {
        if (!(0, _isArray2.default)(task)) {
            // no dependencies
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
        }

        var dependencies = task.slice(0, task.length - 1);
        var remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
        }
        uncheckedDependencies[key] = remainingDependencies;

        (0, _arrayEach2.default)(dependencies, function (dependencyName) {
            if (!tasks[dependencyName]) {
                throw new Error(&apos;async.auto task `&apos; + key + &apos;` has a non-existent dependency `&apos; + dependencyName + &apos;` in &apos; + dependencies
.join(&apos;, &apos;));
            }
            addListener(dependencyName, function () {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                    enqueueTask(key, task);
                }
            });
        });
    });

    checkForDeadlocks();
    processQueue();

    function enqueueTask(key, task) {
        readyTasks.push(function () {
            runTask(key, task);
        });
    }

    function processQueue() {
        if (readyTasks.length === 0 &amp;&amp; runningTasks === 0) {
            return callback(null, results);
        }
        while (readyTasks.length &amp;&amp; runningTasks &lt; concurrency) {
            var run = readyTasks.shift();
            run();
        }
    }

    function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
        }

        taskListeners.push(fn);
    }

    function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        (0, _arrayEach2.default)(taskListeners, function (fn) {
            fn();
        });
        processQueue();
    }

    function runTask(key, task) {
        if (hasError) return;

        var taskCallback = (0, _onlyOnce2.default)(function (err, result) {
            runningTasks--;
            if (arguments.length &gt; 2) {
                result = (0, _slice2.default)(arguments, 1);
            }
            if (err) {
                var safeResults = {};
                (0, _baseForOwn2.default)(results, function (val, rkey) {
                    safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = Object.create(null);

                callback(err, safeResults);
            } else {
                results[key] = result;
                taskComplete(key);
            }
        });

        runningTasks++;
        var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);
        if (task.length &gt; 1) {
            taskFn(results, taskCallback);
        } else {
            taskFn(taskCallback);
        }
    }

    function checkForDeadlocks() {
        // Kahn&apos;s algorithm
        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
        // http://connalle.blogspot.com/2013...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback. Results are always returned; however, if an
* error occurs, no further `tasks` will be performed, and the results object
* will only contain partial results. Invoked with (err, results).
* @returns undefined
* @example
*
* async.<span class="apidocCodeKeywordSpan">auto</span>({
*     // this function will just be passed a callback
*     readData: async.apply(fs.readFile, &apos;data.txt&apos;, &apos;utf-8&apos;),
*     showData: [&apos;readData&apos;, function(results, cb) {
*         // results.readData is the file&apos;s contents
*         // ...
*     }]
* }, callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.autoInject" id="apidoc.element.async.index.autoInject">
        function <span class="apidocSignatureSpan">async.index.</span>autoInject
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function autoInject(tasks, callback) {
    var newTasks = {};

    (0, _baseForOwn2.default)(tasks, function (taskFn, key) {
        var params;
        var fnIsAsync = (0, _wrapAsync.isAsync)(taskFn);
        var hasNoDeps = !fnIsAsync &amp;&amp; taskFn.length === 1 || fnIsAsync &amp;&amp; taskFn.length === 0;

        if ((0, _isArray2.default)(taskFn)) {
            params = taskFn.slice(0, -1);
            taskFn = taskFn[taskFn.length - 1];

            newTasks[key] = params.concat(params.length &gt; 0 ? newTask : taskFn);
        } else if (hasNoDeps) {
            // no dependencies, use the function as-is
            newTasks[key] = taskFn;
        } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 &amp;&amp; !fnIsAsync &amp;&amp; params.length === 0) {
                throw new Error(&quot;autoInject task functions require explicit parameters.&quot;);
            }

            // remove callback param
            if (!fnIsAsync) params.pop();

            newTasks[key] = params.concat(newTask);
        }

        function newTask(results, taskCb) {
            var newArgs = (0, _arrayMap2.default)(params, function (name) {
                return results[name];
            });
            newArgs.push(taskCb);
            (0, _wrapAsync2.default)(taskFn).apply(null, newArgs);
        }
    });

    (0, _auto2.default)(newTasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - An optional callback which is called when all
* the tasks have been completed. It receives the `err` argument if any `tasks`
* pass an error to their callback, and a `results` object with any completed
* task results, similar to `auto`.
* @example
*
* //  The example from `auto` can be rewritten as follows:
* async.<span class="apidocCodeKeywordSpan">autoInject</span>({
*     get_data: function(callback) {
*         // async code to get some data
*         callback(null, &apos;data&apos;, &apos;converted to array&apos;);
*     },
*     make_folder: function(callback) {
*         // async code to create a directory to store a file in
*         // this is run at the same time as getting the data
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.cargo" id="apidoc.element.async.index.cargo">
        function <span class="apidocSignatureSpan">async.index.</span>cargo
        <span class="apidocSignatureSpan">(worker, payload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cargo(worker, payload) {
  return (0, _queue2.default)(worker, 1, payload);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* unlimited.
* @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
* attached as certain properties to listen for specific events during the
* lifecycle of the cargo and inner queue.
* @example
*
* // create a cargo object with payload 2
* var cargo = async.<span class="apidocCodeKeywordSpan">cargo</span>(function(tasks, callback) {
*     for (var i=0; i&lt;tasks.length; i++) {
*         console.log(&apos;hello &apos; + tasks[i].name);
*     }
*     callback();
* }, 2);
*
* // add some items
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.compose" id="apidoc.element.async.index.compose">
        function <span class="apidocSignatureSpan">async.index.</span>compose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function () /*...args*/{
  return _seq2.default.apply(null, (0, _slice2.default)(arguments).reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * function mul3(n, callback) {
 *     setTimeout(function () {
 *         callback(null, n * 3);
 *     }, 10);
 * }
 *
 * var add1mul3 = async.<span class="apidocCodeKeywordSpan">compose</span>(mul3, add1);
 * add1mul3(4, function (err, result) {
 *     // result now equals 15
 * });
 */
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.concat" id="apidoc.element.async.index.concat">
        function <span class="apidocSignatureSpan">async.index.</span>concat
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concat = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    value: true
});

exports.default = function (fn /*, ...args*/) {
    var args = (0, _slice2.default)(arguments, 1);
    return function () /*callArgs*/{
        var callArgs = (0, _slice2.default)(arguments);
        return fn.apply(null, args.<span class="apidocCodeKeywordSpan">concat</span>(callArgs));
    };
};

var _slice = require(&apos;./internal/slice&apos;);

var _slice2 = _interopRequireDefault(_slice);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.concatLimit" id="apidoc.element.async.index.concatLimit">
        function <span class="apidocSignatureSpan">async.index.</span>concatLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatLimit = function (coll, limit, iteratee, callback) {
    callback = callback || _noop2.default;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _mapLimit2.default)(coll, limit, function (val, callback) {
        _iteratee(val, function (err /*, ...args*/) {
            if (err) return callback(err);
            return callback(null, (0, _slice2.default)(arguments, 1));
        });
    }, function (err, mapResults) {
        var result = [];
        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                result = _concat.apply(result, mapResults[i]);
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.concatSeries" id="apidoc.element.async.index.concatSeries">
        function <span class="apidocSignatureSpan">async.index.</span>concatSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">concatSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.constant" id="apidoc.element.async.index.constant">
        function <span class="apidocSignatureSpan">async.index.</span>constant
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constant = function () /*...values*/{
    var values = (0, _slice2.default)(arguments);
    var args = [null].concat(values);
    return function () /*...ignoredArgs, callback*/{
        var callback = arguments[arguments.length - 1];
        return callback.apply(this, args);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {...*} arguments... - Any number of arguments to automatically invoke
* callback with.
* @returns {AsyncFunction} Returns a function that when invoked, automatically
* invokes the callback with the previous given arguments.
* @example
*
* async.waterfall([
*     async.<span class="apidocCodeKeywordSpan">constant</span>(42),
*     function (value, next) {
*         // value === 42
*     },
*     //...
* ], callback);
*
* async.waterfall([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.detect" id="apidoc.element.async.index.detect">
        function <span class="apidocSignatureSpan">async.index.</span>detect
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detect = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the `iteratee` functions have finished.
* Result will be the first item in the array that passes the truth test
* (iteratee) or the value `undefined` if none passed. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">detect</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // result now equals the first file in the list that exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.detectLimit" id="apidoc.element.async.index.detectLimit">
        function <span class="apidocSignatureSpan">async.index.</span>detectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.detectSeries" id="apidoc.element.async.index.detectSeries">
        function <span class="apidocSignatureSpan">async.index.</span>detectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">detectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.dir" id="apidoc.element.async.index.dir">
        function <span class="apidocSignatureSpan">async.index.</span>dir
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dir = function (fn) {
    var args = (0, _slice2.default)(arguments, 1);
    args.push(function (err /*, ...args*/) {
        var args = (0, _slice2.default)(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                (0, _arrayEach2.default)(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    (0, _wrapAsync2.default)(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var hello = function(name, callback) {
 *     setTimeout(function() {
 *         callback(null, {hello: name});
 *     }, 1000);
 * };
 *
 * // in the node repl
 * node&gt; async.<span class="apidocCodeKeywordSpan">dir</span>(hello, &apos;world&apos;);
 * {hello: &apos;world&apos;}
 */
exports.default = (0, _consoleFunc2.default)(&apos;dir&apos;);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.doDuring" id="apidoc.element.async.index.doDuring">
        function <span class="apidocSignatureSpan">async.index.</span>doDuring
        <span class="apidocSignatureSpan">(fn, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doDuring(fn, test, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _fn = (0, _wrapAsync2.default)(fn);
    var _test = (0, _wrapAsync2.default)(test);

    function next(err /*, ...args*/) {
        if (err) return callback(err);
        var args = (0, _slice2.default)(arguments, 1);
        args.push(check);
        _test.apply(this, args);
    };

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    check(null, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.doUntil" id="apidoc.element.async.index.doUntil">
        function <span class="apidocSignatureSpan">async.index.</span>doUntil
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doUntil(iteratee, test, callback) {
    (0, _doWhilst2.default)(iteratee, function () {
        return !test.apply(this, arguments);
    }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.doWhilst" id="apidoc.element.async.index.doWhilst">
        function <span class="apidocSignatureSpan">async.index.</span>doWhilst
        <span class="apidocSignatureSpan">(iteratee, test, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function doWhilst(iteratee, test, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    var next = function (err /*, ...args*/) {
        if (err) return callback(err);
        var args = (0, _slice2.default)(arguments, 1);
        if (test.apply(this, args)) return _iteratee(next);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.during" id="apidoc.element.async.index.during">
        function <span class="apidocSignatureSpan">async.index.</span>during
        <span class="apidocSignatureSpan">(test, fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function during(test, fn, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _fn = (0, _wrapAsync2.default)(fn);
    var _test = (0, _wrapAsync2.default)(test);

    function next(err) {
        if (err) return callback(err);
        _test(check);
    }

    function check(err, truth) {
        if (err) return callback(err);
        if (!truth) return callback(null);
        _fn(next);
    }

    _test(check);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called after the test
* function has failed and repeated execution of `fn` has stopped. `callback`
* will be passed an error, if one occurred, otherwise `null`.
* @example
*
* var count = 0;
*
* async.<span class="apidocCodeKeywordSpan">during</span>(
*     function (callback) {
*         return callback(null, count &lt; 5);
*     },
*     function (callback) {
*         count++;
*         setTimeout(callback, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.each" id="apidoc.element.async.index.each">
        function <span class="apidocSignatureSpan">async.index.</span>each
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * function call. The signature is `(..args, callback)`. If invoked with any
 * arguments, `callback` is required.
 * @example
 *
 * async.applyEach([enableSearch, updateSchema], &apos;bucket&apos;, callback);
 *
 * // partial application example:
 * async.<span class="apidocCodeKeywordSpan">each</span>(
 *     buckets,
 *     async.applyEach([enableSearch, updateSchema]),
 *     callback
 * );
 */
exports.default = (0, _applyEach2.default)(_map2.default);
module.exports = exports[&apos;default&apos;];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.eachLimit" id="apidoc.element.async.index.eachLimit">
        function <span class="apidocSignatureSpan">async.index.</span>eachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.eachOf" id="apidoc.element.async.index.eachOf">
        function <span class="apidocSignatureSpan">async.index.</span>eachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.eachOfLimit" id="apidoc.element.async.index.eachOfLimit">
        function <span class="apidocSignatureSpan">async.index.</span>eachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.eachOfSeries" id="apidoc.element.async.index.eachOfSeries">
        function <span class="apidocSignatureSpan">async.index.</span>eachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.eachSeries" id="apidoc.element.async.index.eachSeries">
        function <span class="apidocSignatureSpan">async.index.</span>eachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.ensureAsync" id="apidoc.element.async.index.ensureAsync">
        function <span class="apidocSignatureSpan">async.index.</span>ensureAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureAsync(fn) {
    if ((0, _wrapAsync.isAsync)(fn)) return fn;
    return (0, _initialParams2.default)(function (args, callback) {
        var sync = true;
        args.push(function () {
            var innerArgs = arguments;
            if (sync) {
                (0, _setImmediate2.default)(function () {
                    callback.apply(null, innerArgs);
                });
            } else {
                callback.apply(null, innerArgs);
            }
        });
        fn.apply(this, args);
        sync = false;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
3. The callback can accept any number of arguments
4. The first argument passed to the callback will be treated as an error result, if the argument is truthy
5. Any number of result arguments can be passed after the &quot;error&quot; argument
6. The callback is called once and exactly once, either on the same tick or later tick of the JavaScript event loop.

There were several cases where Async accepted some functions that did not strictly have these properties, most notably `auto`, `
every`, `some`, `filter`, `reject` and `detect`.

Another theme is performance. We have eliminated internal deferrals in all cases where they make sense. For example, in `waterfall
` and `auto`, there was a `setImmediate` between each task -- these deferrals have been removed. A `setImmediate` call can add up
 to 1ms of delay. This might not seem like a lot, but it can add up if you are using many Async functions in the course of processing
 a HTTP request, for example. Nearly all asynchronous functions that do I/O already have some sort of deferral built in, so the
extra deferral is unnecessary. The trade-off of this change is removing our built-in stack-overflow defense. Many synchronous callback
 calls in series can quickly overflow the JS call stack. If you do have a function that is sometimes synchronous (calling its callback
 on the same tick), and are running into stack overflows, wrap it with `async.<span class="apidocCodeKeywordSpan">ensureAsync</span
>()`.

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.every" id="apidoc.element.async.index.every">
        function <span class="apidocSignatureSpan">async.index.</span>every
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">every = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee must complete with a boolean result value.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result will be either `true` or `false`
* depending on the values of the async tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">every</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then every file exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.everyLimit" id="apidoc.element.async.index.everyLimit">
        function <span class="apidocSignatureSpan">async.index.</span>everyLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everyLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.everySeries" id="apidoc.element.async.index.everySeries">
        function <span class="apidocSignatureSpan">async.index.</span>everySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">everySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.filter" id="apidoc.element.async.index.filter">
        function <span class="apidocSignatureSpan">async.index.</span>filter
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filter = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} iteratee - A truth test to apply to each item in `coll`.
* The `iteratee` is passed a `callback(err, truthValue)`, which must be called
* with a boolean argument once it has completed. Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">filter</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of the existing files
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.filterLimit" id="apidoc.element.async.index.filterLimit">
        function <span class="apidocSignatureSpan">async.index.</span>filterLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.filterSeries" id="apidoc.element.async.index.filterSeries">
        function <span class="apidocSignatureSpan">async.index.</span>filterSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">filterSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.find" id="apidoc.element.async.index.find">
        function <span class="apidocSignatureSpan">async.index.</span>find
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.findLimit" id="apidoc.element.async.index.findLimit">
        function <span class="apidocSignatureSpan">async.index.</span>findLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.findSeries" id="apidoc.element.async.index.findSeries">
        function <span class="apidocSignatureSpan">async.index.</span>findSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.foldl" id="apidoc.element.async.index.foldl">
        function <span class="apidocSignatureSpan">async.index.</span>foldl
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _eachOfSeries2.default)(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.foldr" id="apidoc.element.async.index.foldr">
        function <span class="apidocSignatureSpan">async.index.</span>foldr
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = (0, _slice2.default)(array).reverse();
  (0, _reduce2.default)(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEach" id="apidoc.element.async.index.forEach">
        function <span class="apidocSignatureSpan">async.index.</span>forEach
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, iteratee, callback) {
  (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEachLimit" id="apidoc.element.async.index.forEachLimit">
        function <span class="apidocSignatureSpan">async.index.</span>forEachLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEachOf" id="apidoc.element.async.index.forEachOf">
        function <span class="apidocSignatureSpan">async.index.</span>forEachOf
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOf = function (coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} [callback] - A callback which is called when all
* `iteratee` functions have finished, or an error occurs. Invoked with (err).
* @example
*
* var obj = {dev: &quot;/dev.json&quot;, test: &quot;/test.json&quot;, prod: &quot;/prod.json&quot;};
* var configs = {};
*
* async.<span class="apidocCodeKeywordSpan">forEachOf</span>(obj, function (value, key, callback) {
*     fs.readFile(__dirname + value, &quot;utf8&quot;, function (err, data) {
*         if (err) return callback(err);
*         try {
*             configs[key] = JSON.parse(data);
*         } catch (e) {
*             return callback(e);
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEachOfLimit" id="apidoc.element.async.index.forEachOfLimit">
        function <span class="apidocSignatureSpan">async.index.</span>forEachOfLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eachOfLimit(coll, limit, iteratee, callback) {
  (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEachOfSeries" id="apidoc.element.async.index.forEachOfSeries">
        function <span class="apidocSignatureSpan">async.index.</span>forEachOfSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachOfSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forEachSeries" id="apidoc.element.async.index.forEachSeries">
        function <span class="apidocSignatureSpan">async.index.</span>forEachSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forEachSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.forever" id="apidoc.element.async.index.forever">
        function <span class="apidocSignatureSpan">async.index.</span>forever
        <span class="apidocSignatureSpan">(fn, errback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forever(fn, errback) {
    var done = (0, _onlyOnce2.default)(errback || _noop2.default);
    var task = (0, _wrapAsync2.default)((0, _ensureAsync2.default)(fn));

    function next(err) {
        if (err) return done(err);
        task(next);
    }
    next();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @category Control Flow
* @param {AsyncFunction} fn - an async function to call repeatedly.
* Invoked with (next).
* @param {Function} [errback] - when `fn` passes an error to it&apos;s callback,
* this function will be called, and execution stops. Invoked with (err).
* @example
*
* async.<span class="apidocCodeKeywordSpan">forever</span>(
*     function(next) {
*         // next is suitable for passing to things that need a callback(err [, whatever]);
*         // it will result in this function being called again.
*     },
*     function(err) {
*         // if next is called with a value in its first parameter, it will appear
*         // in here as &apos;err&apos;, and execution will stop.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.groupBy" id="apidoc.element.async.index.groupBy">
        function <span class="apidocSignatureSpan">async.index.</span>groupBy
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBy = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* The iteratee should complete with a `key` to group the value under.
* Invoked with (value, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. Result is an `Object` whoses
* properties are arrays of values which returned the corresponding key.
* @example
*
* async.<span class="apidocCodeKeywordSpan">groupBy</span>([&apos;userId1&apos;, &apos;userId2&apos;, &apos;userId3&apos;], function
(userId, callback) {
*     db.findById(userId, function(err, user) {
*         if (err) return callback(err);
*         return callback(null, user.age);
*     });
* }, function(err, result) {
*     // result is object containing the userIds grouped by age
*     // e.g. { 30: [&apos;userId1&apos;, &apos;userId3&apos;], 42: [&apos;userId2&apos;]};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.groupByLimit" id="apidoc.element.async.index.groupByLimit">
        function <span class="apidocSignatureSpan">async.index.</span>groupByLimit
        <span class="apidocSignatureSpan">(coll, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupByLimit = function (coll, limit, iteratee, callback) {
    callback = callback || _noop2.default;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _mapLimit2.default)(coll, limit, function (val, callback) {
        _iteratee(val, function (err, key) {
            if (err) return callback(err);
            return callback(null, { key: key, val: val });
        });
    }, function (err, mapResults) {
        var result = {};
        // from MDN, handle object having an `hasOwnProperty` prop
        var hasOwnProperty = Object.prototype.hasOwnProperty;

        for (var i = 0; i &lt; mapResults.length; i++) {
            if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;

                if (hasOwnProperty.call(result, key)) {
                    result[key].push(val);
                } else {
                    result[key] = [val];
                }
            }
        }

        return callback(err, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.groupBySeries" id="apidoc.element.async.index.groupBySeries">
        function <span class="apidocSignatureSpan">async.index.</span>groupBySeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">groupBySeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.inject" id="apidoc.element.async.index.inject">
        function <span class="apidocSignatureSpan">async.index.</span>inject
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _eachOfSeries2.default)(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.log" id="apidoc.element.async.index.log">
        function <span class="apidocSignatureSpan">async.index.</span>log
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function (fn) {
    var args = (0, _slice2.default)(arguments, 1);
    args.push(function (err /*, ...args*/) {
        var args = (0, _slice2.default)(arguments, 1);
        if (typeof console === &apos;object&apos;) {
            if (err) {
                if (console.error) {
                    console.error(err);
                }
            } else if (console[name]) {
                (0, _arrayEach2.default)(args, function (x) {
                    console[name](x);
                });
            }
        }
    });
    (0, _wrapAsync2.default)(fn).apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     },
*     email_link: function(write_file, callback) {
*         // once the file is written let&apos;s email a link to it...
*         // write_file contains the filename returned by write_file.
*         callback(null, {&apos;file&apos;:write_file, &apos;email&apos;:&apos;user@example.com&apos;});
*     }
* }, function(err, results) {
*     console.<span class="apidocCodeKeywordSpan">log</span>(&apos;err = &apos;, err);
*     console.log(&apos;email_link = &apos;, results.email_link);
* });
*
* // If you are using a JS minifier that mangles parameter names, `autoInject`
* // will not work with plain functions, since the parameter names will be
* // collapsed to a single letter identifier.  To work around this, you can
* // explicitly specify the names of the parameters your task function needs
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.map" id="apidoc.element.async.index.map">
        function <span class="apidocSignatureSpan">async.index.</span>map
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var FN_ARG = /(=.+)?(\s*)$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

function parseParams(func) {
   func = func.toString().replace(STRIP_COMMENTS, &apos;&apos;);
   func = func.match(FN_ARGS)[2].replace(&apos; &apos;, &apos;&apos;);
   func = func ? func.split(FN_ARG_SPLIT) : [];
   func = func.<span class="apidocCodeKeywordSpan">map</span>(function (arg) {
       return (0, _trim2.default)(arg.replace(FN_ARG, &apos;&apos;));
   });
   return func;
}

/**
* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.mapLimit" id="apidoc.element.async.index.mapLimit">
        function <span class="apidocSignatureSpan">async.index.</span>mapLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

```javascript
var async = require(&quot;async&quot;);

// ...or ES2017 async functions
async.<span class="apidocCodeKeywordSpan">mapLimit</span>(urls, 5, async function(url) {
    const response = await fetch(url)
    return response.body
}, (err, results) =&gt; {
    if (err) throw err
    // results is now an array of the response bodies
    console.log(results)
})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.mapSeries" id="apidoc.element.async.index.mapSeries">
        function <span class="apidocSignatureSpan">async.index.</span>mapSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         return callback(null, cache[arg]); // this would be synchronous!!
 *     } else {
 *         doSomeIO(arg, callback); // this IO would be asynchronous
 *     }
 * }
 *
 * // this has a risk of stack overflows if many results are cached in a row
 * async.<span class="apidocCodeKeywordSpan">mapSeries</span>(args, sometimesAsync, done);
 *
 * // this will defer sometimesAsync&apos;s callback if necessary,
 * // preventing stack overflows
 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
 */
function ensureAsync(fn) {
if ((0, _wrapAsync.isAsync)(fn)) return fn;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.mapValues" id="apidoc.element.async.index.mapValues">
        function <span class="apidocSignatureSpan">async.index.</span>mapValues
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValues = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (value, key, callback).
* @param {Function} [callback] - A callback which is called when all `iteratee`
* functions have finished, or an error occurs. `result` is a new object consisting
* of each key from `obj`, with each transformed value on the right-hand side.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">mapValues</span>({
*     f1: &apos;file1&apos;,
*     f2: &apos;file2&apos;,
*     f3: &apos;file3&apos;
* }, function (file, key, callback) {
*   fs.stat(file, callback);
* }, function(err, result) {
*     // result is now a map of stats for each file, e.g.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.mapValuesLimit" id="apidoc.element.async.index.mapValuesLimit">
        function <span class="apidocSignatureSpan">async.index.</span>mapValuesLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapValuesLimit(obj, limit, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var newObj = {};
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _eachOfLimit2.default)(obj, limit, function (val, key, next) {
        _iteratee(val, key, function (err, result) {
            if (err) return next(err);
            newObj[key] = result;
            next();
        });
    }, function (err) {
        callback(err, newObj);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.mapValuesSeries" id="apidoc.element.async.index.mapValuesSeries">
        function <span class="apidocSignatureSpan">async.index.</span>mapValuesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapValuesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.memoize" id="apidoc.element.async.index.memoize">
        function <span class="apidocSignatureSpan">async.index.</span>memoize
        <span class="apidocSignatureSpan">(fn, hasher)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function memoize(fn, hasher) {
    var memo = Object.create(null);
    var queues = Object.create(null);
    hasher = hasher || _identity2.default;
    var _fn = (0, _wrapAsync2.default)(fn);
    var memoized = (0, _initialParams2.default)(function memoized(args, callback) {
        var key = hasher.apply(null, args);
        if (has(memo, key)) {
            (0, _setImmediate2.default)(function () {
                callback.apply(null, memo[key]);
            });
        } else if (has(queues, key)) {
            queues[key].push(callback);
        } else {
            queues[key] = [callback];
            _fn.apply(null, args.concat(function () /*args*/{
                var args = (0, _slice2.default)(arguments);
                memo[key] = args;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i &lt; l; i++) {
                    q[i].apply(null, args);
                }
            }));
        }
    });
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @returns {AsyncFunction} a memoized version of `fn`
 * @example
 *
 * var slow_fn = function(name, callback) {
 *     // do something
 *     callback(null, result);
 * };
 * var fn = async.<span class="apidocCodeKeywordSpan">memoize</span>(slow_fn);
 *
 * // fn can now be used as if it were slow_fn
 * fn(&apos;some name&apos;, function() {
 *     // callback
 * });
 */
function memoize(fn, hasher) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.nextTick" id="apidoc.element.async.index.nextTick">
        function <span class="apidocSignatureSpan">async.index.</span>nextTick
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextTick = function (fn) {
    var args = (0, _slice2.default)(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} [callback] - A callback which is called after all the
 * `iteratee` functions have finished. Result is the reduced value. Invoked with
 * (err, result).
 * @example
 *
 * async.reduce([1,2,3], 0, function(memo, item, callback) {
 *     // pointless async:
 *     process.<span class="apidocCodeKeywordSpan">nextTick</span>(function() {
 *         callback(null, memo + item)
 *     });
 * }, function(err, result) {
 *     // result is now equal to the last value of memo, which is 6
 * });
 */
function reduce(coll, memo, iteratee, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.parallel" id="apidoc.element.async.index.parallel">
        function <span class="apidocSignatureSpan">async.index.</span>parallel
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, callback) {
  (0, _parallel2.default)(_eachOf2.default, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* arguments to. Invokes with (arguments...).
* @param {...*} arguments... - Any number of arguments to automatically apply
* when the continuation is called.
* @returns {Function} the partially-applied function
* @example
*
* // using apply
* async.<span class="apidocCodeKeywordSpan">parallel</span>([
*     async.apply(fs.writeFile, &apos;testfile1&apos;, &apos;test1&apos;),
*     async.apply(fs.writeFile, &apos;testfile2&apos;, &apos;test2&apos;)
* ]);
*
*
* // the same process without using apply
* async.parallel([
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.parallelLimit" id="apidoc.element.async.index.parallelLimit">
        function <span class="apidocSignatureSpan">async.index.</span>parallelLimit
        <span class="apidocSignatureSpan">(tasks, limit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallelLimit(tasks, limit, callback) {
  (0, _parallel2.default)((0, _eachOfLimit2.default)(limit), tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.priorityQueue" id="apidoc.element.async.index.priorityQueue">
        function <span class="apidocSignatureSpan">async.index.</span>priorityQueue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">priorityQueue = function (worker, concurrency) {
    // Start with a normal queue
    var q = (0, _queue2.default)(worker, concurrency);

    // Override push to accept second parameter representing priority
    q.push = function (data, priority, callback) {
        if (callback == null) callback = _noop2.default;
        if (typeof callback !== &apos;function&apos;) {
            throw new Error(&apos;task callback must be a function&apos;);
        }
        q.started = true;
        if (!(0, _isArray2.default)(data)) {
            data = [data];
        }
        if (data.length === 0) {
            // call drain immediately if there are no tasks
            return (0, _setImmediate2.default)(function () {
                q.drain();
            });
        }

        priority = priority || 0;
        var nextNode = q._tasks.head;
        while (nextNode &amp;&amp; priority &gt;= nextNode.priority) {
            nextNode = nextNode.next;
        }

        for (var i = 0, l = data.length; i &lt; l; i++) {
            var item = {
                data: data[i],
                priority: priority,
                callback: callback
            };

            if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
            } else {
                q._tasks.push(item);
            }
        }
        (0, _setImmediate2.default)(q.process);
    };

    // Remove unshift function
    delete q.unshift;

    return q;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.queue" id="apidoc.element.async.index.queue">
        function <span class="apidocSignatureSpan">async.index.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (worker, concurrency) {
  var _worker = (0, _wrapAsync2.default)(worker);
  return (0, _queue2.default)(function (items, cb) {
    _worker(items[0], cb);
  }, concurrency, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.<span class="apidocCodeKeywordSpan">queue</span>(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.race" id="apidoc.element.async.index.race">
        function <span class="apidocSignatureSpan">async.index.</span>race
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function race(tasks, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks)) return callback(new TypeError(&apos;First argument to race must be an array of functions&apos;));
    if (!tasks.length) return callback();
    for (var i = 0, l = tasks.length; i &lt; l; i++) {
        (0, _wrapAsync2.default)(tasks[i])(callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Another big performance win has been re-implementing `queue`, `cargo`, and `priorityQueue` with [doubly linked lists](https://en
.wikipedia.org/wiki/Doubly_linked_list) instead of arrays. This has lead to queues being an order of [magnitude faster on large
sets of tasks](https://github.com/caolan/async/pull/1205).

## New Features

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.<span class="apidocCodeKeywordSpan">race</span>()`. It will run an array of async tasks in
 parallel and will call its callback with the result of the first task to respond. ([#568](https://github.com/caolan/async/issues
/568), [#1038](https://github.com/caolan/async/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.reflect()`](http://bluebirdjs.com/docs/api/reflect.html), a wrapper for
 async tasks that always succeeds, by gathering results and errors into an object.  ([#942](https://github.com/caolan/async/issues
/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.reduce" id="apidoc.element.async.index.reduce">
        function <span class="apidocSignatureSpan">async.index.</span>reduce
        <span class="apidocSignatureSpan">(coll, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduce(coll, memo, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _eachOfSeries2.default)(coll, function (x, i, callback) {
        _iteratee(memo, x, function (err, v) {
            memo = v;
            callback(err);
        });
    }, function (err) {
        callback(err, memo);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* main `callback` is immediately called with the error.
* Invoked with (memo, item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the reduced value. Invoked with
* (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reduce</span>([1,2,3], 0, function(memo, item, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         callback(null, memo + item)
*     });
* }, function(err, result) {
*     // result is now equal to the last value of memo, which is 6
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.reduceRight" id="apidoc.element.async.index.reduceRight">
        function <span class="apidocSignatureSpan">async.index.</span>reduceRight
        <span class="apidocSignatureSpan">(array, memo, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reduceRight(array, memo, iteratee, callback) {
  var reversed = (0, _slice2.default)(array).reverse();
  (0, _reduce2.default)(reversed, memo, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.reflect" id="apidoc.element.async.index.reflect">
        function <span class="apidocSignatureSpan">async.index.</span>reflect
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflect(fn) {
    var _fn = (0, _wrapAsync2.default)(fn);
    return (0, _initialParams2.default)(function reflectOn(args, reflectCallback) {
        args.push(function callback(error, cbArg) {
            if (error) {
                reflectCallback(null, { error: error });
            } else {
                var value;
                if (arguments.length &lt;= 2) {
                    value = cbArg;
                } else {
                    value = (0, _slice2.default)(arguments, 1);
                }
                reflectCallback(null, { value: value });
            }
        });

        return _fn.apply(this, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

- Async is now modularized. Individual functions can be `require()`d from the main package. (`require(&apos;async/auto&apos;)`) ([#
984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Async is also available as a collection of ES2015 modules in the new `async-es` package. (`import {forEachSeries} from &apos;async
-es&apos;`) ([#984](https://github.com/caolan/async/issues/984), [#996](https://github.com/caolan/async/issues/996))
- Added `race`, analogous to `Promise.race()`. It will run an array of async tasks in parallel and will call its callback with the
 result of the first task to respond. ([#568](https://github.com/caolan/async/issues/568), [#1038](https://github.com/caolan/async
/issues/1038))
- Collection methods now accept ES2015 iterators.  Maps, Sets, and anything that implements the iterator spec can now be passed
directly to `each`, `map`, `parallel`, etc.. ([#579](https://github.com/caolan/async/issues/579), [#839](https://github.com/caolan
/async/issues/839), [#1074](https://github.com/caolan/async/issues/1074))
- Added `mapValues`, for mapping over the properties of an object and returning an object with the same keys. ([#1157](https://github
.com/caolan/async/issues/1157), [#1177](https://github.com/caolan/async/issues/1177))
- Added `timeout`, a wrapper for an async function that will make the task time-out after the specified time. ([#1007](https://github
.com/caolan/async/issues/1007), [#1027](https://github.com/caolan/async/issues/1027))
- Added `reflect` and `reflectAll`, analagous to [`Promise.<span class="apidocCodeKeywordSpan">reflect</span>()`](http://bluebirdjs
.com/docs/api/reflect.html), a wrapper for async tasks that always succeeds, by gathering results and errors into an object.  ([#
942](https://github.com/caolan/async/issues/942), [#1012](https://github.com/caolan/async/issues/1012), [#1095](https://github.com
/caolan/async/issues/1095))
- `constant` supports dynamic arguments -- it will now always use its last argument as the callback. ([#1016](https://github.com
/caolan/async/issues/1016), [#1052](https://github.com/caolan/async/issues/1052))
- `setImmediate` and `nextTick` now support arguments to partially apply to the deferred function, like the node-native versions
 do. ([#940](https://github.com/caolan/async/issues/940), [#1053](https://github.com/caolan/async/issues/1053))
- `auto` now supports resolving cyclic dependencies using [Kahn&apos;s algorithm](https://en.wikipedia.org/wiki/Topological_sorting
#Kahn.27s_algorithm) ([#1140](https://github.com/caolan/async/issues/1140)).
- Added `autoInject`, a relative of `auto` that automatically spreads a task&apos;s dependencies as arguments to the task function
. ([#608](https://github.com/caolan/async/issues/608), [#1055](https://github.com/caolan/async/issues/1055), [#1099](https://github
.com/caolan/async/issues/1099), [#1100](https://github.com/caolan/async/issues/1100))
- You can now limit the concurrency of `auto` tasks. ([#635](https://github.com/caolan/async/issues/635), [#637](https://github.
com/caolan/async/issues/637))
- Added `retryable`, a relative of `retry` that wraps an async function, making it retry when called. ([#1058](https://github.com
/caolan/async/issues/1058))
- `retry` now supports specifying a function that determines the next time interval, useful for exponential backoff, logging and
 other retry strategies. ([#1161](https://github.com/caolan/async/issues/1161))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.reflectAll" id="apidoc.element.async.index.reflectAll">
        function <span class="apidocSignatureSpan">async.index.</span>reflectAll
        <span class="apidocSignatureSpan">(tasks)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function reflectAll(tasks) {
    var results;
    if ((0, _isArray2.default)(tasks)) {
        results = (0, _arrayMap3.default)(tasks, _reflect2.default);
    } else {
        results = {};
        (0, _baseForOwn2.default)(tasks, function (task, key) {
            results[key] = _reflect2.default.call(this, task);
        });
    }
    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     function(callback) {
*         setTimeout(function() {
*             callback(null, &apos;two&apos;);
*         }, 100);
*     }
* ];
*
* async.parallel(async.<span class="apidocCodeKeywordSpan">reflectAll</span>(tasks),
* // optional callback
* function(err, results) {
*     // values
*     // results[0].value = &apos;one&apos;
*     // results[1].error = Error(&apos;bad stuff happened&apos;)
*     // results[2].value = &apos;two&apos;
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.reject" id="apidoc.element.async.index.reject">
        function <span class="apidocSignatureSpan">async.index.</span>reject
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reject = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `coll`.
* The should complete with a boolean value as its `result`.
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">reject</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, results) {
*     // results now equals an array of missing files
*     createFiles(results);
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.rejectLimit" id="apidoc.element.async.index.rejectLimit">
        function <span class="apidocSignatureSpan">async.index.</span>rejectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.rejectSeries" id="apidoc.element.async.index.rejectSeries">
        function <span class="apidocSignatureSpan">async.index.</span>rejectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rejectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.retry" id="apidoc.element.async.index.retry">
        function <span class="apidocSignatureSpan">async.index.</span>retry
        <span class="apidocSignatureSpan">(opts, task, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function retry(opts, task, callback) {
    var DEFAULT_TIMES = 5;
    var DEFAULT_INTERVAL = 0;

    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: (0, _constant2.default)(DEFAULT_INTERVAL)
    };

    function parseTimes(acc, t) {
        if (typeof t === &apos;object&apos;) {
            acc.times = +t.times || DEFAULT_TIMES;

            acc.intervalFunc = typeof t.interval === &apos;function&apos; ? t.interval : (0, _constant2.default)(+t.interval || DEFAULT_INTERVAL
);

            acc.errorFilter = t.errorFilter;
        } else if (typeof t === &apos;number&apos; || typeof t === &apos;string&apos;) {
            acc.times = +t || DEFAULT_TIMES;
        } else {
            throw new Error(&quot;Invalid arguments for async.retry&quot;);
        }
    }

    if (arguments.length &lt; 3 &amp;&amp; typeof opts === &apos;function&apos;) {
        callback = task || _noop2.default;
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || _noop2.default;
    }

    if (typeof task !== &apos;function&apos;) {
        throw new Error(&quot;Invalid arguments for async.retry&quot;);
    }

    var _task = (0, _wrapAsync2.default)(task);

    var attempt = 1;
    function retryAttempt() {
        _task(function (err) {
            if (err &amp;&amp; attempt++ &lt; options.times &amp;&amp; (typeof options.errorFilter != &apos;function&apos; || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
            } else {
                callback.apply(null, arguments);
            }
        });
    }

    retryAttempt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @example
*
* // The `retry` function can be used as a stand-alone control flow by passing
* // a callback, as shown below:
*
* // try calling apiMethod 3 times
* async.<span class="apidocCodeKeywordSpan">retry</span>(3, apiMethod, function(err, result) {
*     // do something with the result
* });
*
* // try calling apiMethod 3 times, waiting 200 ms between each retry
* async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
*     // do something with the result
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.retryable" id="apidoc.element.async.index.retryable">
        function <span class="apidocSignatureSpan">async.index.</span>retryable
        <span class="apidocSignatureSpan">(opts, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">retryable = function (opts, task) {
    if (!task) {
        task = opts;
        opts = null;
    }
    var _task = (0, _wrapAsync2.default)(task);
    return (0, _initialParams2.default)(function (args, callback) {
        function taskFn(cb) {
            _task.apply(null, args.concat(cb));
        }

        if (opts) (0, _retry2.default)(opts, taskFn, callback);else (0, _retry2.default)(taskFn, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (...args, callback).
* @returns {AsyncFunction} The wrapped function, which when invoked, will
* retry on an error, based on the parameters specified in `opts`.
* This function will accept the same parameters as `task`.
* @example
*
* async.auto({
*     dep1: async.<span class="apidocCodeKeywordSpan">retryable</span>(3, getFromFlakyService),
*     process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {
*         maybeProcessData(results.dep1, cb);
*     })]
* }, callback);
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.select" id="apidoc.element.async.index.select">
        function <span class="apidocSignatureSpan">async.index.</span>select
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">select = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.selectLimit" id="apidoc.element.async.index.selectLimit">
        function <span class="apidocSignatureSpan">async.index.</span>selectLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.selectSeries" id="apidoc.element.async.index.selectSeries">
        function <span class="apidocSignatureSpan">async.index.</span>selectSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">selectSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.seq" id="apidoc.element.async.index.seq">
        function <span class="apidocSignatureSpan">async.index.</span>seq
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function seq() /*...functions*/{
    var _functions = (0, _arrayMap2.default)(arguments, _wrapAsync2.default);
    return function () /*...args*/{
        var args = (0, _slice2.default)(arguments);
        var that = this;

        var cb = args[args.length - 1];
        if (typeof cb == &apos;function&apos;) {
            args.pop();
        } else {
            cb = _noop2.default;
        }

        (0, _reduce2.default)(_functions, args, function (newargs, fn, cb) {
            fn.apply(that, newargs.concat(function (err /*, ...nextargs*/) {
                var nextargs = (0, _slice2.default)(arguments, 1);
                cb(err, nextargs);
            }));
        }, function (err, results) {
            cb.apply(that, [err].concat(results));
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* // Requires lodash (or underscore), express3 and dresende&apos;s orm2.
* // Part of an app, that fetches cats of the logged user.
* // This example uses `seq` function to avoid overnesting and error
* // handling clutter.
* app.get(&apos;/cats&apos;, function(request, response) {
*     var User = request.models.User;
*     async.<span class="apidocCodeKeywordSpan">seq</span>(
*         _.bind(User.get, User),  // &apos;User.get&apos; has signature (id, callback(err, data))
*         function(user, fn) {
*             user.getCats(fn);      // &apos;getCats&apos; has signature (callback(err, data))
*         }
*     )(req.session.user_id, function (err, cats) {
*         if (err) {
*             console.error(err);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.series" id="apidoc.element.async.index.series">
        function <span class="apidocSignatureSpan">async.index.</span>series
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function series(tasks, callback) {
  (0, _parallel2.default)(_eachOfSeries2.default, tasks, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* [async functions]{@link AsyncFunction} to run in series.
* Each function can complete with any number of optional `result` values.
* @param {Function} [callback] - An optional callback to run once all the
* functions have completed. This function gets a results array (or object)
* containing all the result arguments passed to the `task` callbacks. Invoked
* with (err, result).
* @example
* async.<span class="apidocCodeKeywordSpan">series</span>([
*     function(callback) {
*         // do some stuff ...
*         callback(null, &apos;one&apos;);
*     },
*     function(callback) {
*         // do some more stuff ...
*         callback(null, &apos;two&apos;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.setImmediate" id="apidoc.element.async.index.setImmediate">
        function <span class="apidocSignatureSpan">async.index.</span>setImmediate
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setImmediate = function (fn) {
    var args = (0, _slice2.default)(arguments, 1);
    defer(function () {
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * var call_order = [];
 * async.nextTick(function() {
 *     call_order.push(&apos;two&apos;);
 *     // call_order now equals [&apos;one&apos;,&apos;two&apos;]
 * });
 * call_order.push(&apos;one&apos;);
 *
 * async.<span class="apidocCodeKeywordSpan">setImmediate</span>(function (a, b, c) {
 *     // a, b, and c equal 1, 2, and 3
 * }, 1, 2, 3);
 */
var _defer;

if (_setImmediate.hasNextTick) {
_defer = process.nextTick;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.some" id="apidoc.element.async.index.some">
        function <span class="apidocSignatureSpan">async.index.</span>some
        <span class="apidocSignatureSpan">(obj, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">some = function (obj, iteratee, callback) {
    return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} [callback] - A callback which is called as soon as any
* iteratee returns `true`, or after all the iteratee functions have finished.
* Result will be either `true` or `false` depending on the values of the async
* tests. Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">some</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath
, callback) {
*     fs.access(filePath, function(err) {
*         callback(null, !err)
*     });
* }, function(err, result) {
*     // if result is true then at least one of the files exists
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.someLimit" id="apidoc.element.async.index.someLimit">
        function <span class="apidocSignatureSpan">async.index.</span>someLimit
        <span class="apidocSignatureSpan">(obj, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someLimit = function (obj, limit, iteratee, callback) {
    return fn((0, _eachOfLimit2.default)(limit), obj, (0, _wrapAsync2.default)(iteratee), callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.someSeries" id="apidoc.element.async.index.someSeries">
        function <span class="apidocSignatureSpan">async.index.</span>someSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.sortBy" id="apidoc.element.async.index.sortBy">
        function <span class="apidocSignatureSpan">async.index.</span>sortBy
        <span class="apidocSignatureSpan">(coll, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortBy(coll, iteratee, callback) {
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    (0, _map2.default)(coll, function (x, callback) {
        _iteratee(x, function (err, criteria) {
            if (err) return callback(err);
            callback(null, { value: x, criteria: criteria });
        });
    }, function (err, results) {
        if (err) return callback(err);
        callback(null, (0, _arrayMap2.default)(results.sort(comparator), (0, _baseProperty2.default)(&apos;value&apos;)));
    });

    function comparator(left, right) {
        var a = left.criteria,
            b = right.criteria;
        return a &lt; b ? -1 : a &gt; b ? 1 : 0;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Invoked with (item, callback).
* @param {Function} callback - A callback which is called after all the
* `iteratee` functions have finished, or an error occurs. Results is the items
* from the original `coll` sorted by the values returned by the `iteratee`
* calls. Invoked with (err, results).
* @example
*
* async.<span class="apidocCodeKeywordSpan">sortBy</span>([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(file
, callback) {
*     fs.stat(file, function(err, stats) {
*         callback(err, stats.mtime);
*     });
* }, function(err, results) {
*     // results is now the original array of files sorted by
*     // modified date
* });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.timeout" id="apidoc.element.async.index.timeout">
        function <span class="apidocSignatureSpan">async.index.</span>timeout
        <span class="apidocSignatureSpan">(asyncFn, milliseconds, info)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeout(asyncFn, milliseconds, info) {
    var fn = (0, _wrapAsync2.default)(asyncFn);

    return (0, _initialParams2.default)(function (args, callback) {
        var timedOut = false;
        var timer;

        function timeoutCallback() {
            var name = asyncFn.name || &apos;anonymous&apos;;
            var error = new Error(&apos;Callback function &quot;&apos; + name + &apos;&quot; timed out.&apos;);
            error.code = &apos;ETIMEDOUT&apos;;
            if (info) {
                error.info = info;
            }
            timedOut = true;
            callback(error);
        }

        args.push(function () {
            if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
            }
        });

        // setup timer and call original function
        timer = setTimeout(timeoutCallback, milliseconds);
        fn.apply(null, args);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*         // do some stuff ...
*
*         // return processed data
*         return callback(null, data);
*     });
* }
*
* var wrapped = async.<span class="apidocCodeKeywordSpan">timeout</span>(myFunction, 1000);
*
* // call `wrapped` as you would `myFunction`
* wrapped({ bar: &apos;bar&apos; }, function(err, data) {
*     // if `myFunction` takes &lt; 1000 ms to execute, `err`
*     // and `data` will have their expected values
*
*     // else `err` will be an Error with the code &apos;ETIMEDOUT&apos;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.times" id="apidoc.element.async.index.times">
        function <span class="apidocSignatureSpan">async.index.</span>times
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">times = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* var createUser = function(id, callback) {
*     callback(null, {
*         id: &apos;user&apos; + id
*     });
* };
*
* // generate 5 users
* async.<span class="apidocCodeKeywordSpan">times</span>(5, function(n, next) {
*     createUser(n, function(err, user) {
*         next(err, user);
*     });
* }, function(err, users) {
*     // we should now have 5 users
* });
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.timesLimit" id="apidoc.element.async.index.timesLimit">
        function <span class="apidocSignatureSpan">async.index.</span>timesLimit
        <span class="apidocSignatureSpan">(count, limit, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function timeLimit(count, limit, iteratee, callback) {
  var _iteratee = (0, _wrapAsync2.default)(iteratee);
  (0, _mapLimit2.default)((0, _baseRange2.default)(0, count, 1), limit, _iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.timesSeries" id="apidoc.element.async.index.timesSeries">
        function <span class="apidocSignatureSpan">async.index.</span>timesSeries
        <span class="apidocSignatureSpan">(iterable, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">timesSeries = function (iterable, iteratee, callback) {
    return fn(iterable, limit, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.transform" id="apidoc.element.async.index.transform">
        function <span class="apidocSignatureSpan">async.index.</span>transform
        <span class="apidocSignatureSpan">(coll, accumulator, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(coll, accumulator, iteratee, callback) {
    if (arguments.length &lt;= 3) {
        callback = iteratee;
        iteratee = accumulator;
        accumulator = (0, _isArray2.default)(coll) ? [] : {};
    }
    callback = (0, _once2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);

    (0, _eachOf2.default)(coll, function (v, k, cb) {
        _iteratee(accumulator, v, k, cb);
    }, function (err) {
        callback(err, accumulator);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* collection that potentially modifies the accumulator.
* Invoked with (accumulator, item, key, callback).
* @param {Function} [callback] - A callback which is called after all the
* `iteratee` functions have finished. Result is the transformed accumulator.
* Invoked with (err, result).
* @example
*
* async.<span class="apidocCodeKeywordSpan">transform</span>([1,2,3], function(acc, item, index, callback) {
*     // pointless async:
*     process.nextTick(function() {
*         acc.push(item * 2)
*         callback(null)
*     });
* }, function(err, result) {
*     // result is now equal to [2, 4, 6]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.tryEach" id="apidoc.element.async.index.tryEach">
        function <span class="apidocSignatureSpan">async.index.</span>tryEach
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tryEach(tasks, callback) {
    var error = null;
    var result;
    callback = callback || _noop2.default;
    (0, _eachSeries2.default)(tasks, function (task, callback) {
        (0, _wrapAsync2.default)(task)(function (err, res /*, ...args*/) {
            if (arguments.length &gt; 2) {
                result = (0, _slice2.default)(arguments, 1);
            } else {
                result = res;
            }
            error = err;
            callback(!err);
        });
    }, function () {
        callback(error, result);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* completion with an error `err` (which can be `null`) and an optional `result`
* value.
* @param {Function} [callback] - An optional callback which is called when one
* of the tasks has succeeded, or all have failed. It receives the `err` and
* `result` arguments of the last attempt at completing the `task`. Invoked with
* (err, results).
* @example
* async.<span class="apidocCodeKeywordSpan">tryEach</span>([
*     function getDataFromFirstWebsite(callback) {
*         // Try getting the data from the first website
*         callback(err, data);
*     },
*     function getDataFromSecondWebsite(callback) {
*         // First website failed,
*         // Try getting the data from the backup website
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.unmemoize" id="apidoc.element.async.index.unmemoize">
        function <span class="apidocSignatureSpan">async.index.</span>unmemoize
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unmemoize(fn) {
    return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.until" id="apidoc.element.async.index.until">
        function <span class="apidocSignatureSpan">async.index.</span>until
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function until(test, iteratee, callback) {
    (0, _whilst2.default)(function () {
        return !test.apply(this, arguments);
    }, iteratee, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.waterfall" id="apidoc.element.async.index.waterfall">
        function <span class="apidocSignatureSpan">async.index.</span>waterfall
        <span class="apidocSignatureSpan">(tasks, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">waterfall = function (tasks, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks)) return callback(new Error(&apos;First argument to waterfall must be an array of functions&apos;));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
    }

    function next(err /*, ...args*/) {
        if (err || taskIndex === tasks.length) {
            return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
    }

    nextTask([]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Function} func - The synchronous function, or Promise-returning
* function to convert to an {@link AsyncFunction}.
* @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
* invoked with `(args..., callback)`.
* @example
*
* // passing a regular synchronous function
* async.<span class="apidocCodeKeywordSpan">waterfall</span>([
*     async.apply(fs.readFile, filename, &quot;utf8&quot;),
*     async.asyncify(JSON.parse),
*     function (data, next) {
*         // data is the result of parsing the text.
*         // If there was a parsing error, it would have been caught.
*     }
* ], callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.whilst" id="apidoc.element.async.index.whilst">
        function <span class="apidocSignatureSpan">async.index.</span>whilst
        <span class="apidocSignatureSpan">(test, iteratee, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function whilst(test, iteratee, callback) {
    callback = (0, _onlyOnce2.default)(callback || _noop2.default);
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    if (!test()) return callback(null);
    var next = function (err /*, ...args*/) {
        if (err) return callback(err);
        if (test()) return _iteratee(next);
        var args = (0, _slice2.default)(arguments, 1);
        callback.apply(null, [null].concat(args));
    };
    _iteratee(next);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* function has failed and repeated execution of `iteratee` has stopped. `callback`
* will be passed an error and any arguments passed to the final `iteratee`&apos;s
* callback. Invoked with (err, [results]);
* @returns undefined
* @example
*
* var count = 0;
* async.<span class="apidocCodeKeywordSpan">whilst</span>(
*     function() { return count &lt; 5; },
*     function(callback) {
*         count++;
*         setTimeout(function() {
*             callback(null, count);
*         }, 1000);
*     },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.index.wrapSync" id="apidoc.element.async.index.wrapSync">
        function <span class="apidocSignatureSpan">async.index.</span>wrapSync
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asyncify(func) {
    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if ((0, _isObject2.default)(result) &amp;&amp; typeof result.then === &apos;function&apos;) {
            result.then(function (value) {
                invokeCallback(callback, null, value);
            }, function (err) {
                invokeCallback(callback, err.message ? err : new Error(err));
            });
        } else {
            callback(null, result);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.async.wrapAsync" id="apidoc.module.async.wrapAsync">module async.wrapAsync</a></h1>


    <h2>
        <a href="#apidoc.element.async.wrapAsync.default" id="apidoc.element.async.wrapAsync.default">
        function <span class="apidocSignatureSpan">async.wrapAsync.</span>default
        <span class="apidocSignatureSpan">(asyncFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
        q.process();
    };
}

var isProcessing = false;
var q = {
    _tasks: new _DoublyLinkedList2.<span class="apidocCodeKeywordSpan">default</span>(),
    concurrency: concurrency,
    payload: payload,
    saturated: _noop2.default,
    unsaturated: _noop2.default,
    buffer: concurrency / 4,
    empty: _noop2.default,
    drain: _noop2.default,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.async.wrapAsync.isAsync" id="apidoc.element.async.wrapAsync.isAsync">
        function <span class="apidocSignatureSpan">async.wrapAsync.</span>isAsync
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAsync(fn) {
    return supportsSymbol &amp;&amp; fn[Symbol.toStringTag] === &apos;AsyncFunction&apos;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
